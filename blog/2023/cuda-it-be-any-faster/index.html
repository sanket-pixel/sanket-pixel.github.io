<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>CUDA it Be Any Faster? | Sanket Shah</title>
    <meta name="author" content="Sanket R. Shah">
    <meta name="description" content="Voxelization using CUDA programming">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://sanket-pixel.github.io//blog/2023/cuda-it-be-any-faster/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/">Sanket Shah</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">CUDA it Be Any Faster?</h1>
    <p class="post-meta">August 5, 2023</p>
    <p class="post-tags">
      <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>
        ·  
        <a href="/blog/tag/nvidia">
          <i class="fas fa-hashtag fa-sm"></i> nvidia</a>  
          <a href="/blog/tag/cuda">
          <i class="fas fa-hashtag fa-sm"></i> cuda</a>  
          
        ·  
        <a href="/blog/category/cuda">
          <i class="fas fa-tag fa-sm"></i> cuda</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <h4 id="experience-the-exhilarating-world-of-nvidias-cuda-programming-as-we-revolutionize-point-cloud-processing-in-computer-vision-and-robotics-voxelization-the-process-of-converting-3d-points-into-discrete-voxels-has-faced-challenges-with-traditional-cpu-based-methods-limiting-groundbreaking-innovations-but-fear-not-as-we-harness-the-immense-power-of-parallelization-for-a-monumental-leap-of-over-580x-times-over-traditional-cpu-dive-into-cudas-awe-inspiring-realm-where-each-point-gets-its-own-thread-enabling-lightning-fast-voxelization-and-opening-the-doors-to-real-time-applications-join-us-on-this-thrilling-ride-and-witness-the-magic-of-cuda-as-we-rewrite-the-future-of-point-cloud-processing-lets-embrace-the-sheer-power-of-cuda-together-and-change-the-game">Experience the exhilarating world of NVIDIA’s CUDA programming as we revolutionize point cloud processing in computer vision and robotics. Voxelization, the process of converting 3D points into discrete voxels, has faced challenges with traditional CPU-based methods, limiting groundbreaking innovations. But fear not, as we harness the immense power of parallelization for a monumental leap of over 580x times over traditional CPU! Dive into CUDA’s awe-inspiring realm, where each point gets its own thread, enabling lightning-fast voxelization and opening the doors to real-time applications. Join us on this thrilling ride and witness the magic of CUDA as we rewrite the future of point cloud processing. Let’s embrace the sheer power of CUDA together and change the game!</h4>

<p><br></p>

<div style="width: 100%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/voxelize.gif-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/voxelize.gif-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/voxelize.gif-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/voxelize.gif" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
   Input Point Cloud on the Left and Voxelized Point Cloud using CUDA programming on right. 
</div>
</div>

<h2 id="why-should-you-read-this-blog">Why Should You Read This Blog?</h2>

<p>Buckle up as we’re about to embark on an exhilarating journey into the world of NVIDIA GPU programming and CUDA wizardry. So, grab your favorite caffeinated beverage and prepare for some adrenaline-pumping excitement!</p>

<p>Now, you might be wondering, “Why should I read this blog? Is it going to be another dull and dreary technical piece?” Well, fear not! This blog is anything but ordinary. We’re here to show you the mind-blowing power of CUDA programming on NVIDIA GPUs, and we’ve got a jaw-dropping example to demonstrate just that: voxelization!</p>

<p>Okay, you might be thinking, “Voxelization? What in the world is that? Sounds like a made-up word from a sci-fi movie!” Well, in a way, it kind of is! Voxelization is the magical process of taking a ginormous LiDAR point cloud and breaking it down into tiny cubic chunks called voxels. Think of it as pixelating a 3D world, but on a whole new level!</p>

<p>Now, hold on to your seat because here comes the fun part: we’re going to do all this voxelization stuff using the mighty NVIDIA GPUs and CUDA. That’s right, the same GPUs used in gaming rigs to unleash stunning graphics and epic frame rates are going to help us crunch numbers like there’s no tomorrow.  Together, we’ll venture into the depths of parallel programming, where our algorithms will run at supersonic speeds, leaving ordinary CPUs gasping for breath. Instead of using the age old for-loops to process every point one after another, we will process these points, all at once, by using a seperate thread for every point in the point cloud. This way, we make every thread count, squeezing out every ounce of performance, that the NVIDIA GPU has to offer. These concepts of parallelization that we will use for point-cloud processing can be seamlessly used for any other realm where parallelization is an option.</p>

<p>But beware! As we venture further into the realm of CUDA programming, things might get a bit hairy. New concepts and parallel programming lingo might make you scratch your head in confusion. But hey, don’t give up just yet! Remember, the path to greatness is often paved with challenges. And in this case, the reward at the end of the tunnel is an unreal, mind-boggling, jaw-dropping <code class="language-plaintext highlighter-rouge">580x speedup</code>!</p>

<p>Yes, you heard that right! By the time we’re done here, you’ll have a GPU-based voxelization algorithm that can chew through mountains of LiDAR data at an incredible speed, leaving your CPU-bound counterparts in the dust. It’s like having a supersonic jet compared to a horse-drawn carriage!</p>

<p>So, stick with us, and we promise it’ll be worth it. Sure, there might be moments when you feel like you’re lost in a maze of CUDA syntax or buried under an avalanche of parallel processing concepts. But fear not, brave adventurer! We’re here to guide you, step by step, through the intricacies of GPU programming.</p>

<p>So, are you ready for the ride of a lifetime? Strap on your GPU-powered jetpack, and let’s dive into the mind-bending universe of CUDA programming and voxelization. Together, we’ll unlock the secrets of parallel processing and witness the awe-inspiring 580x speedup that will leave you marveling at the wonders of modern technology!</p>

<p><br></p>

<h2 id="1-what-is-voxelization">1. What is Voxelization?</h2>

<p>Voxelization is a fundamental process in computer graphics and 3D data analysis that involves converting continuous 3D space into a discrete representation using small cubic units known as “voxels.” The term <code class="language-plaintext highlighter-rouge">voxel</code> is a combination of <code class="language-plaintext highlighter-rouge">volume</code> and <code class="language-plaintext highlighter-rouge">pixel</code>, and it serves as the 3D equivalent of a 2D pixel.</p>

<p>Imagine we have a 3D object or scene that we want to represent digitally. Voxelization begins by enclosing this continuous 3D space within an imaginary 3D grid. This grid subdivides the entire space into a series of equally-sized cubic voxels, and each cell is a voxel. Similar to pixels in a 2D image, each voxel corresponds to a specific region within the 3D space.</p>

<p>The next step is to analyze the contents of each voxel and determine whether it is occupied or empty. This process is often referred to as <code class="language-plaintext highlighter-rouge">filling</code> the voxels. To fill the voxels, we examine the objects or entities within the 3D space and determine which voxels they intersect or occupy.</p>

<p>For example, consider a 3D point cloud obtained from a LiDAR sensor. Each point in the point cloud represents a 3D coordinate in space. During voxelization, the points falling within a voxel’s boundaries are considered as <code class="language-plaintext highlighter-rouge">occupied</code> while the voxels without any points are <code class="language-plaintext highlighter-rouge">empty</code>.</p>

<p>By analyzing the presence or absence of objects in each voxel, we create a binary representation of the 3D space. The voxels that are occupied are marked with a value of 1, while the empty voxels are assigned a value of 0. This binary representation forms a digital 3D model, often referred to as a <code class="language-plaintext highlighter-rouge">voxel grid</code> or <code class="language-plaintext highlighter-rouge">voxel map</code>.</p>

<p>In the context of this blog, <code class="language-plaintext highlighter-rouge">voxelization</code> refers to the initial step of assigning individual 3D points from a LiDAR point cloud to discrete voxels within a 3D grid. Each voxel represents a small cubic region in the 3D space, and the process of voxelization categorizes points based on their spatial location. Points falling within a voxel’s boundaries are considered “occupied,” while voxels without any points are labeled as “empty.”</p>

<p>After the voxelization step, the blog proceeds to <code class="language-plaintext highlighter-rouge">feature extraction</code>. In this step, we compute the average of certain features for all the points that belong to each voxel. The features of interest in our case are the x, y, z coordinates, and the intensity of the LiDAR points. By averaging these features for all the points within a voxel, we obtain a condensed representation of the original point cloud data.</p>

<p>The voxelization and feature extraction steps are essential in processing large-scale LiDAR point cloud data efficiently and effectively. They provide several key benefits:</p>

<p><strong>Data Summarization</strong>: Voxelization enables us to partition the complex and continuous point cloud data into smaller, discrete units, represented by voxels. This categorization allows us to summarize the content of the entire point cloud and simplifies subsequent analysis.</p>

<p><strong>Reduced Computational Complexity</strong>: The process of assigning points to voxels significantly reduces the computational burden by processing points at a voxel level rather than individually. This reduction in complexity is crucial when dealing with massive point cloud datasets, as it enables faster processing and analysis.</p>

<p><strong>Compact Representation</strong>: Feature extraction by averaging the x, y, z coordinates, and intensity within each voxel results in a compact representation of the original point cloud. Instead of dealing with millions of individual points, we obtain summarized information for each voxel, making it more manageable for downstream tasks.</p>

<p><strong>Efficient Task-Specific Analysis</strong>: The condensed representation obtained through feature extraction provides valuable insights for various 3D tasks such as object detection, moving object segmentation, velocity estimation, and more. By processing voxel-level information, these tasks become computationally tractable and more efficient.</p>

<h2 id="2-primer-on-cuda-programming">2. Primer on CUDA Programming</h2>

<p>Before we embark on the exhilarating journey of GPU-powered voxelization, let’s take a moment to familiarize ourselves with the essence of CUDA programming. If you’re new to this realm, fear not, for we shall unravel the key concepts step by step, and soon, you’ll be navigating through the seas of parallel processing with confidence.</p>

<p><em>Understanding CUDA: The Power of Parallelism</em></p>

<p>At its core, CUDA is NVIDIA’s powerful parallel computing platform and programming model. It harnesses the raw computational might of NVIDIA GPUs to tackle intricate problems at breathtaking speeds. Imagine orchestrating a symphony where hundreds or thousands of independent operations perform in harmony, each contributing to the grand performance.</p>

<p><em>The Building Blocks of CUDA: Threads, Blocks, and Grids</em></p>

<p>CUDA operates on the principles of threads, blocks, and grids. Threads are the elemental units of computation, executing independently on the GPU. They group together into blocks, and these blocks, in turn, form a grid. This orchestrated arrangement of threads, blocks, and grids conducts the seamless symphony of parallelism.</p>

<p><em>A Simple CUDA Example: Adding Numbers in Parallel</em></p>

<p>Let’s commence our CUDA journey with a classic example: adding numbers in parallel. This seemingly simple task is a profound introduction to the world of parallel processing.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cuda_runtime.h&gt;</span><span class="cp">
</span>
<span class="c1">// CUDA kernel to add two arrays in parallel</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">addNumbers</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numElements</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">&lt;</span> <span class="n">numElements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Array size and memory allocation</span>
    <span class="kt">int</span> <span class="n">numElements</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">numElements</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">h_a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">h_b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">h_c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="c1">// Initialize arrays with some values</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numElements</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">h_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">h_b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Allocate GPU memory</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">d_a</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">d_b</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">d_c</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_a</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_b</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_c</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="c1">// Copy input arrays from host to GPU memory</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_a</span><span class="p">,</span> <span class="n">h_a</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_b</span><span class="p">,</span> <span class="n">h_b</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

    <span class="c1">// Launch the CUDA kernel with 256 threads per block</span>
    <span class="kt">int</span> <span class="n">blockSize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numBlocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">numElements</span> <span class="o">+</span> <span class="n">blockSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">blockSize</span><span class="p">;</span>
    <span class="n">addNumbers</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span> <span class="n">blockSize</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_a</span><span class="p">,</span> <span class="n">d_b</span><span class="p">,</span> <span class="n">d_c</span><span class="p">,</span> <span class="n">numElements</span><span class="p">);</span>

    <span class="c1">// Copy the result from GPU memory back to host</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">h_c</span><span class="p">,</span> <span class="n">d_c</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>

    <span class="c1">// Free GPU memory and host arrays</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_a</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_b</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_c</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">h_a</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">h_b</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">h_c</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Code Explanation:</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__global__</code> Function: The <code class="language-plaintext highlighter-rouge">addNumbers</code> function is marked as a <code class="language-plaintext highlighter-rouge">__global__</code> function. This indicates that it’s a GPU kernel that will be executed on the GPU.</p>
  </li>
  <li>
    <p>Kernel Launch: The kernel is launched with the <code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;numBlocks, blockSize&gt;&gt;&gt;</code> syntax, specifying the number of blocks (<code class="language-plaintext highlighter-rouge">numBlocks</code>) and the number of threads per block (<code class="language-plaintext highlighter-rouge">blockSize</code>). Each block contains multiple threads, and the threads execute the kernel function in parallel.</p>
  </li>
  <li>
    <p>Thread Indexing: The <code class="language-plaintext highlighter-rouge">tid</code> (thread ID) is calculated using the <code class="language-plaintext highlighter-rouge">blockDim.x</code>, <code class="language-plaintext highlighter-rouge">blockIdx.x</code>, and <code class="language-plaintext highlighter-rouge">threadIdx.x</code> built-in variables. Each thread knows its global ID, allowing it to access the corresponding elements in arrays <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>.</p>
  </li>
  <li>
    <p>Array Initialization: Three arrays <code class="language-plaintext highlighter-rouge">h_a</code>, <code class="language-plaintext highlighter-rouge">h_b</code>, and <code class="language-plaintext highlighter-rouge">h_c</code> are allocated in host memory (<code class="language-plaintext highlighter-rouge">malloc</code>) and initialized with some values. These arrays represent the input arrays <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and the output array <code class="language-plaintext highlighter-rouge">c</code>.</p>
  </li>
  <li>
    <p>Memory Allocation and Data Transfer: Memory is allocated on the GPU using <code class="language-plaintext highlighter-rouge">cudaMalloc</code>, and the input arrays <code class="language-plaintext highlighter-rouge">h_a</code> and <code class="language-plaintext highlighter-rouge">h_b</code> are copied to the GPU memory using <code class="language-plaintext highlighter-rouge">cudaMemcpy</code>.</p>
  </li>
  <li>
    <p>Kernel Execution: The <code class="language-plaintext highlighter-rouge">addNumbers</code> kernel is launched with the specified number of blocks and threads per block. Each thread computes the sum of the corresponding elements of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, storing the result in array <code class="language-plaintext highlighter-rouge">c</code> on the GPU.</p>
  </li>
  <li>
    <p>Result Retrieval: The result is copied back from the GPU memory to the host array <code class="language-plaintext highlighter-rouge">h_c</code> using <code class="language-plaintext highlighter-rouge">cudaMemcpy</code>.</p>
  </li>
  <li>
    <p>Memory Deallocation: GPU memory is freed using <code class="language-plaintext highlighter-rouge">cudaFree</code>, and host arrays are freed using <code class="language-plaintext highlighter-rouge">free</code>.</p>
  </li>
</ol>

<p><strong>Compiling the CUDA Code with CMake</strong></p>

<p>To compile the CUDA code, we can use CMake, a popular build system that supports CUDA projects. Below is a minimal CMakeLists.txt file to build the CUDA example:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>CUDAExample<span class="p">)</span>

<span class="c1"># Find CUDA</span>
<span class="nb">find_package</span><span class="p">(</span>CUDA REQUIRED<span class="p">)</span>

<span class="c1"># Set C++ version</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 14<span class="p">)</span>

<span class="c1"># Include CUDA headers</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CUDA_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>

<span class="c1"># Add the CUDA source file and executable</span>
<span class="nf">cuda_add_executable</span><span class="p">(</span>cuda_example main.cu<span class="p">)</span>
</code></pre></div></div>

<p><strong>Executing the CUDA Code</strong></p>

<p>Once the CMakeLists.txt file is prepared, follow these steps to execute the CUDA example:</p>

<ol>
  <li>Create a directory (e.g., build) to build the project:
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">mkdir </span>build
  <span class="nb">cd </span>build
</code></pre></div>    </div>
  </li>
  <li>Generate the Makefile using CMake:
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  cmake ..
</code></pre></div>    </div>
  </li>
  <li>Build the project:
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  make
</code></pre></div>    </div>
  </li>
  <li>Run the CUDA executable:
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>./cuda_example
</code></pre></div>    </div>
  </li>
</ol>

<p>And with that, we cover the basics of CUDA ,and  we are now ready to witness how these concepts are harnessed to implement highly efficient voxelization using the parallel processing capabilities of GPUs. Before we embark on this exciting journey into the world of GPU-accelerated voxelization, let’s delve deeper into the intuition and mechanics of this process. Get ready to experience the wonders of voxelization and the incredible performance boost it brings!</p>

<p><br></p>

<h2 id="3-intuition">3. Intuition</h2>
<p>In this section, we will embark on an intuitive exploration of the point cloud voxelization process using CUDA. To that end, let’s first set the stage by taking a look at a simple 2D grid. We’ll create a 3x3 grid and randomly select 14 points with most points within its boundaries. Some points will also lie slightly outside the grid to make the example more interesting. The voxels here are analogous to voxels. Visualizing this grid and its sample points, we get the following plot:</p>

<div style="width: 60%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/points-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/points-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/points-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/points.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
   Example 2D grid with 14 points. The voxels are analogous to voxels.
</div>
</div>

<p>Now, let us understand one last detail before we begin the actual processing. In the figure shown below, on the left, we have a 2D grid representing the voxels with their corresponding indices ranging from (0, 0) to (2, 2). Each voxel in the grid is identified by its x and y coordinates, starting from the bottom-left corner and progressing towards the top-right corner. However, from now on, we will refer to this serialized integer index as <code class="language-plaintext highlighter-rouge">voxel_offset</code>,  which uniquely represents each voxel in a sequential order from 0 to 8, as shown on the right side of the figure.</p>
<div style="width: 70%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/serialize-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/serialize-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/serialize-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/serialize.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
   Left : 2D indices of the voxels (i,j), the x and ycoordinate respectively. Right : Flattened out 1D indices.
</div> 
</div>
<p>This <code class="language-plaintext highlighter-rouge">voxel_offset</code> plays a crucial role in the upcoming CUDA-based voxelization process, allowing us to efficiently access and process voxel data in a linear manner. By representing the grid in this serialized format, we can easily map each voxel’s position to its corresponding voxel ID, making the hash map implementation more streamlined and intuitive. These concepts will get clear later.</p>

<p>The process of converting a point cloud to voxels using CUDA involves three main steps: <em>hash map building</em>, <em>voxelization</em>, and <em>feature extraction</em> as shown in the Figure below. Hash map building efficiently stores information about unique voxels that contain points, eliminating the need to process all grid voxels. Voxelization assigns each point to its corresponding voxel, creating a serialized array that stores point features for all voxels. Finally, feature extraction calculates the average features for each voxel, resulting in an efficient representation of point cloud features. In all of these steps, CUDA programming helps in parallelization, in that, every point or every voxel is processed on a seperate thread in parallel. In the following section we will understand each of these steps intuitively using our toy example before we delve into the real deal.</p>

<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/steps-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/steps-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/steps-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/steps.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
    The key steps involved in CUDA based Voxelization
</div>
<p><br></p>

<h3 id="a-build-hashmaps">A. Build Hashmaps</h3>
<p>Now, let’s explore the first step of building hash maps. Before diving into the intricacies of building hash maps, it’s essential to understand why they are necessary. In our 3x3 grid example, we observed that out of the 9 voxels, only 6 voxels contain points, while the remaining 3 voxels are entirely empty (as marked in red in the figure below). This situation presents a compelling opportunity for optimization, as processing all 9x9 voxels would be highly inefficient and computationally wasteful. That’s where hash maps comes into play.</p>

<div style="width: 70%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/empty_voxels-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/empty_voxels-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/empty_voxels-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/empty_voxels.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
     Why use hash maps? To process only non-empty voxels.
</div> 
</div>

<p>Hash maps offer an efficient way to store and access data by associating each voxel’s position with its corresponding information. By directly mapping the unique voxel positions as keys( <code class="language-plaintext highlighter-rouge">voxel_offset</code> as described earlier to their respective <code class="language-plaintext highlighter-rouge">voxel_id</code>s ( will be explained soon) as values, we can efficiently eliminate the need to process all the empty voxels. This approach drastically reduces memory consumption and processing time, making voxelization of point clouds significantly faster and more resource-efficient. We perform several operations on every point in the point cloud, for building the hash map. All these operation is performed for each point on a seperate thread in parallel using CUDA. Let’s now understand how we go from our scattered 2D points, with certain empty voxels, to an efficient and compact hashmap :</p>
<ol>
  <li>
<strong>Filtering Points</strong>: We begin by filtering out all the points that lie outside the defined boundary. These points are not relevant for our voxelization and can be safely excluded from further processing.</li>
  <li>
    <p><strong>Voxel Computation</strong> : We take each remaining point from the filtered set and calculate its corresponding voxel indices (voxel_x, voxel_y) using a general point-to-voxel clamping technique. This process ensures that each point is precisely associated with a specific voxel in the 2D grid.</p>

    <p>Let’s consider an example point from our 2D grid with coordinates <code class="language-plaintext highlighter-rouge">(1.8, 2.5)</code>. To convert this point into a voxel, we essentially apply <code class="language-plaintext highlighter-rouge">floor</code> operation to both the coordinates of the points.
 The actual computation is a little more involved, but we will cover that in later section.</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>   Original Point:[1.8, 2.5]
   Clamped Point: [floor(1.8), floor(2.5)] =[1, 2]
</code></pre></div>    </div>

    <p>Now, the clamped point <code class="language-plaintext highlighter-rouge">(1, 2)</code> represents the voxel indices<code class="language-plaintext highlighter-rouge"> (voxel_x, voxel_y)</code> in the 2D grid. This means that the original point <code class="language-plaintext highlighter-rouge">(1.8, 2.5)</code> is associated with the voxel at grid position <code class="language-plaintext highlighter-rouge">(1, 2)</code>. By performing this computation for all points, we establish a one-to-one mapping between each point and its respective voxel in the 2D grid.</p>
  </li>
  <li>
<strong>Hash Table Insertion</strong>: Next, we start the hash table insertion, by passing the key as <code class="language-plaintext highlighter-rouge">voxel_offset</code>. The corresponding value for this key is the unique voxel counter, reffered to as <code class="language-plaintext highlighter-rouge">voxel_id</code>, which counts the current number of voxels being added to the hash table. The hash table is a simple array like data structure, which stores all keys first, followed by their corresponding values as shown in the Figure below.</li>
</ol>
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/hash1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/hash1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/hash1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/hash1.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
    Initial Hash Table ( of size 12). First we store the keys and then the corresponding values.
</div>
<p>The insertion essentially happens in three steps :</p>

<ol>
  <li>
    <p><strong>Hashing the Key (Voxel_Offset):</strong> The first step in the insertion process is to hash the given key, which represents the <code class="language-plaintext highlighter-rouge">voxel_offset</code>. Hashing is a mathematical function that transforms the key into a unique numeric value. In our example, we use a simple hash function that involves multiplying the <code class="language-plaintext highlighter-rouge">voxel_offset</code> by 2.</p>
  </li>
  <li>
    <p><strong>Modulus Operation to Find Slot:</strong> After hashing the key, we apply the <code class="language-plaintext highlighter-rouge">modulus(%)</code> operation with the size of the hash table divided by 2. This helps us find the slot in the hash table where the key-value pair should be inserted. The modulus operation ensures that the slot index remains within the valid range of the hash table.</p>
  </li>
  <li>
    <p><strong>Compare and Swap Operation:</strong> The final step is to perform the compare and swap operation (CAS) on the hash table at the slot obtained from the modulus operation. The CAS operation checks if the slot is empty. If it is, the insertion is successful, and the key-value pair is placed in that slot. However, if the slot is not empty, it indicates a collision, meaning that another key with the same hash value already occupies that slot. In this case, we need to handle the collision by employing a linear probing technique, where we check the next slot in the hash table until we find an empty slot. Here we have assumed the size of hash table to be 12, but in practice the size of the hash table is much larger than number of keys, to avoid collisions.</p>
  </li>
</ol>

<p>By following these three basic steps, we can efficiently insert points into the hash table, associating each voxel’s position with its corresponding unique ID. This enables us to store relevant information about the voxels containing points and optimize the voxelization process. A gentle reminder, that these steps occur every point on seperate thread in parallel. Now, let’s dive into an example to illustrate this process in action.</p>

<h4 id="example-1">Example 1</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Psuedo Code : Example 1

INSERTION 1 : Pt(2.3,2.8) 

/* Simple case where the slot for the given key is empty.
We just insert the key to this slot and increment the value of total voxels by 1.*/

Step 1 : Voxel Computation 
voxel_x = floor(2.3) = 2
voxel_y = floor(2.8) = 2
voxel_offset = (voxel_y * size_y) + voxel_x  = 2*3 + 2 = 8 
key = voxel_offset

Step 2 : Hashing of key 
hash_key = hash(key) = key*2 = 8*2 = 16.

Step 3 : Find Slot using Modulus
slot = hash_key%(hash_size/2) = 16%6 = 4

Step 4 : Compare And Swap
value = total_voxels = 0.
// simple case 
hash_table[slot] = key
hash_table[slot+hash_size/2] = value
total_voxel++

</code></pre></div></div>
<p>As seen in the figure below, we simply insert the given key 8, at the computed slot 4, because it was empty. Then we insert the corresponding value at slot 10, (4+6).
The value is zero because this is the first unique voxel being inserted in the hash table.</p>

<div style="width: 70%;margin: 0 auto;">
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/insert1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/insert1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/insert1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/insert1.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
    Example 1 : Hash insert operation for point Pt(2.3,2.8) in red. Inserting key 8 at slot (4) and value 0, at slot (4+6=10). 
</div> 
</div>

<h4 id="example-2">Example 2</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Psuedo Code : Example 2

INSERTION 2 : Pt(1.8,0.5) 

/* Simple case where the slot for the given key is empty.
We just insert the key to this slot and increment the value of total voxels by 1.*/

Step 1 : Voxel Computation 
voxel_x = floor(1.8) = 1
voxel_y = floor(0.5) = 0
voxel_offset = (voxel_y * size_y) + voxel_x = 0*3 + 1 = 1
key = voxel_offset

Step 2 : Hashing of key 
hash_key = hash(key) = key*2  = 1*2 = 2.

Step 3 : Find Slot using Modulus
slot = hash_key%(hash_size/2) = 2%6 = 2

Step 4 : Compare And Swap
value = total_voxels = 1.
// simple case 
hash_table[slot] = key
hash_table[slot+hash_size/2] = value
total_voxel++

</code></pre></div></div>

<p>As seen in the figure below, we simply insert the given key 1, at the computed slot 2, because it was empty. Then we insert the corresponding value at slot 8, (2+6).
The value is the count of the current voxels, which is 1.</p>

<div style="width: 70%;margin: 0 auto;">
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/insert2-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/insert2-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/insert2-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/insert2.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
     Example 2 : Hash insert operation for point Pt(1.8,0.5) shown in red. Inserting key 1 at slot (2) and value 1, at slot (2+6=8). 
</div> 
</div>

<h4 id="example-3">Example 3</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Psuedo Code : Example 3 

INSERTION 3 : Pt(1.7,2.8) 

/*Collision Case wherein the slot computed uusing hash key is already filled
 up by a different key. In this case, insert the key in the next free slot. */

Step 1 : Voxel Computation 
voxel_x = floor(1.7) = 1
voxel_y = floor(2.8) = 2
voxel_offset = (voxel_y * size_y) + voxel_x = 2*3 + 1 = 7
key = voxel_offset

Step 2 : Hashing of key 
hash_key = hash(key) = key*2 =  7*2 = 14.

Step 3 : Find Slot using Modulus
slot = hash_key%(hash_size/2) = 14%6 = 2

Step 4 : Compare And Swap
value = total_voxels = 2
// collision case
hash_table[slot]!= Empty &amp;&amp; hash_table[slot] != voxel_offset
// insert in next slot ( if free)
hash_table[++slot] = key
hash_table[slot+hash_size/2] = value
total_voxel++

</code></pre></div></div>
<p>Now we look at a more interesting example where the slot computed using the modulus of the hashed key is already present in the hash table. So a collision occurs, because the slot is 
already filled up by a different key. We look at this case while trying to insert a Point (1.7,2.8). In such a case of collision, we simply insert the key in the next free slot, which in this case is slot (3), as shown below.</p>

<div style="width: 70%;margin: 0 auto;">
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/collision-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/collision-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/collision-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/collision.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
     Example 3 : Hash insert operation for point Pt(1.7,2.8) shown in red. The slot (2) already has key 1 present, which is different from key 7. This indicates a collision, we insert in 
     in the next empty slot which is slot 3. This is called linear probing.
</div> 
</div>

<h4 id="example-4">Example 4</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Psuedo Code : Example 4

INSERTION 4 : Pt(1.8,0.5) 

/* Already inserted case where the slot for the given key is not emppty.
 No insertion happens, since slot already has same key. */

Step 1 : Voxel Computation 
voxel_x = floor(1.8) = 1
voxel_y = floor(0.5) = 0
voxel_offset = (voxel_y * size_y) + voxel_x = 0*3 + 1 = 1
key = voxel_offset

Step 2 : Hashing of key 
hash_key = hash(key) = key*2  = 1*2 = 2.

Step 3 : Find Slot using Modulus
slot = hash_key%(hash_size/2) = 2%6 = 2

Step 4 : Compare And Swap
value = total_voxels = 3.
// already inserted case 
hash_table[slot] != Empty &amp;&amp; hash_table[slot] == key
// no insertion.

</code></pre></div></div>

<p>As seen in the figure below, we skip insertion, at the computed slot 2, because it already had the current points key 1. The goal is to only store unique <code class="language-plaintext highlighter-rouge">voxel_offset</code> as key
and the number of such unique voxels as values. Since this <code class="language-plaintext highlighter-rouge">voxel_offset</code> has already been inserted in the hash table and is not unique, we simply skip insertion.</p>

<div style="width: 70%;margin: 0 auto;">
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/already-inserted-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/already-inserted-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/already-inserted-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/already-inserted.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
     Example 4 : Hash insert operation for point Pt(1.3,0.3) shown in red.
     No insertion happens, since slot already has same key.  
</div> 
</div>
<p>After successfully completing the hash insertion step, we have effectively built a hash table that stores the <code class="language-plaintext highlighter-rouge">voxel_offset</code> (representing the flattened voxel position) as keys and the corresponding <code class="language-plaintext highlighter-rouge">voxel_ID</code> as values. The <code class="language-plaintext highlighter-rouge">voxel_ID</code> is an indicator of the total number of unique voxels, which is updated as we encounter new unique voxels during the hash table construction process. This data structure offers two significant advantages. Firstly, it allows us to process only those voxels that contain points, thereby optimizing our further steps. Additionally, the process of mapping a point to its respective voxel becomes a constant-time operation <code class="language-plaintext highlighter-rouge">O(1)</code> due to the efficient key searching capability of the hash table. This constant-time retrieval is significantly faster compared to traditional “dictionary(map)” structures, which involve <code class="language-plaintext highlighter-rouge">O(log(n))</code> time complexity for key searches.
<br>
<br></p>

<h3 id="b-voxelization">B. Voxelization</h3>
<p><br></p>

<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/steps-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/steps-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/steps-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/steps.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
    The key steps involved in CUDA based Voxelization
</div>

<p>Having accomplished the challenging task of creating the hash table, we now move on to the second step: “Voxelization.” In this step, we utilize the hash table to efficiently store information of all points from the same voxel in contiguous memory locations. The objective is to construct an array called <code class="language-plaintext highlighter-rouge">voxel_temp</code> with a size of (<code class="language-plaintext highlighter-rouge">max_voxels</code> * <code class="language-plaintext highlighter-rouge">max_points_per_voxel</code> * <code class="language-plaintext highlighter-rouge">num_features</code>), where all point features for each voxel are stored serially. Points belonging to the same voxel are grouped together in memory, thereby optimizing data access and manipulation. If a voxel contains lesser points than <code class="language-plaintext highlighter-rouge">max_points_per_voxel</code>, then those memory locations are left empty. No points for guessing, that these operations are performed in parallel for every point on a seperate thread. We simplify the process by breaking it down into three logical steps.</p>

<ol>
  <li>
    <p><strong>Compute Voxel Offset from Point</strong>
For each point, we determine the corresponding <code class="language-plaintext highlighter-rouge">voxel_offset</code> as described earlier, using the <code class="language-plaintext highlighter-rouge">floor</code> operation. The <code class="language-plaintext highlighter-rouge">voxel_offset</code> represents a unique identifier for a specific voxel in our 2D grid.</p>
  </li>
  <li>
    <p><strong>Efficiently Find Voxel ID from the Hash Table</strong>
To quickly locate the voxel’s position in the array, we leverage the previously constructed hash table. Using the <code class="language-plaintext highlighter-rouge">voxel_offset</code> as the key, we perform a constant-time search in the hash table to find the corresponding <code class="language-plaintext highlighter-rouge">value</code>, which represents the unique <code class="language-plaintext highlighter-rouge">voxel_ID</code>. The intuition is that while making the hash table, the voxel that was identified first will be entered first in the <code class="language-plaintext highlighter-rouge">voxel_temp</code> array. So <code class="language-plaintext highlighter-rouge">voxel_ID</code> essentially provides us this voxel’s location in the <code class="language-plaintext highlighter-rouge">voxel_temp</code> array.</p>
  </li>
  <li>
    <p><strong>Store Point Features in the Voxel Array</strong>
With the <code class="language-plaintext highlighter-rouge">voxel_ID</code> in hand, we efficiently store the point’s features in the <code class="language-plaintext highlighter-rouge">voxel_temp</code> array. This array is designed to hold all the point features for every voxel in a serialized manner, ensuring that points from the same voxel are stored together. We use the <code class="language-plaintext highlighter-rouge">voxel_ID</code> to determine the correct position in the array to store this point’s features, allowing us to efficiently group all points for each voxel.</p>
  </li>
</ol>

<div style="width: 80%;margin: 0 auto;">
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/voxel-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/voxel-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/voxel-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/voxel.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
     Voxelization :  Points A and B in voxel with voxel_offset=5 are stored in position 4 in voxel_temp array. This position 4 is derived from the hash table by looking up value corresponding to the key 5.
</div> 
</div>

<p>Let’s dive into an example to better understand the Voxelization process. Consider our 3x3 grid, and we have two points: <code class="language-plaintext highlighter-rouge">Point A(2.9, 1.7)</code> and <code class="language-plaintext highlighter-rouge">Point B(2.2, 1.3)</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Step 1: Compute Voxel Offset from Points
- For Point A, we calculate the voxel offset by considering its position in the grid.
- As Point A falls within the voxel at (2, 1), the voxel offset for Point A becomes 5. 
- Similarly, for Point B, the voxel offset is also 5 as it belongs to the same voxel.

Step 2: Find Voxel ID from the Hash Table
- We refer to our previously constructed hash table to quickly determine the voxel_ID 
  associated with voxel_offset 5.
- Upon checking the hash table, we find that the value corresponding to the key 5 is 4
- This indicates that this voxel has been assigned voxel ID 4.

Step 3: Store Point Features in the Voxel Temp Array
- Now that we have the voxel ID (4), we store the point features of Point A and Point B 
  in the voxel_temp array at the 4th position. 
- The voxel_temp array contains information about all points for each voxel, 
  ensuring that points within the same voxel are grouped together.
- Since max_points_per_voxel in our example is 3, but this voxel has only 2 points, we keep 
  the remaining space empty.

</code></pre></div></div>

<p>In the accompanying Figure above, we visually depict this process. We show the 3x3 grid, with <code class="language-plaintext highlighter-rouge">Point A</code> and<code class="language-plaintext highlighter-rouge"> Point B</code> marked inside the voxel they belong to. Next, we present the hash map, where we highlight<code class="language-plaintext highlighter-rouge"> voxel_offset (5)</code> and<code class="language-plaintext highlighter-rouge"> voxel_id (4)</code> to showcase how they are linked. Subsequently, we display the <code class="language-plaintext highlighter-rouge">voxel_temp</code> array, with 6 voxels filled up since only 6 of the 9 voxels in our 3x3 grid have points. Finally, we zoom into the voxel with <code class="language-plaintext highlighter-rouge">voxel_id</code> 4 to witness the two points, A and B, stored serially in this array with their respective <code class="language-plaintext highlighter-rouge">(x,y)</code> values.</p>

<p>This example helps illustrate how the Voxelization process organizes point data efficiently, grouping all points belonging to each voxel together, thanks to the hash map’s guidance. This method significantly speeds up access and processing of point cloud data, making voxel-based approaches highly effective for a wide range of applications.</p>

<p>In summary, after completing the Voxelization step, we achieve an organized arrangement where all points belonging to each voxel are conveniently stored together. The hash table plays a key role, acting as a guide that allows us to locate each voxel’s position in the array with ease.</p>

<p><br></p>

<h3 id="c-feature-extraction">C. Feature extraction</h3>
<p>In the final step of our voxelization process, known as Feature Extraction, we aim to extract meaningful information from the <code class="language-plaintext highlighter-rouge">voxel_temp</code> array, which contains all point features grouped by their respective <code class="language-plaintext highlighter-rouge">voxel_IDs</code>. The goal is to compute average feature values for each voxel and store them in a <code class="language-plaintext highlighter-rouge">voxel_features</code> array. In the feature extraction step, since we are operating on the voxel level ( and not on point level ), we assign one thread for every voxel and perform all operations for every voxel in parallel using CUDA.</p>

<ol>
  <li>
    <p><strong>Prepare for Feature Extraction</strong>
The feature extraction process operates on a per-voxel basis, where each voxel’s features are processed independently. To begin, we initialize the <code class="language-plaintext highlighter-rouge">num_points_per_voxel</code> array to keep track of the number of points in each voxel. Then, for each voxel, we iterate over its points to calculate the total number of points and update the corresponding entry in the <code class="language-plaintext highlighter-rouge">num_points_per_voxel</code> array.</p>
  </li>
  <li>
    <p><strong>Calculate Average Feature Values</strong>
Next, we calculate the average feature values for each voxel. Starting with the first point in the <code class="language-plaintext highlighter-rouge">voxel_temp</code> array for a given voxel, we compute the offset to access this voxel’s data in the array. For subsequent points within the same voxel, we iterate over all features (e.g., x, y, z, intensity, time) and sum up their values.</p>
  </li>
  <li>
    <p><strong>Update Voxel Features</strong>
After summing up the features for all points within the voxel, we calculate the average by dividing the sum by the total number of points in that voxel. These averaged feature values are then updated in the <code class="language-plaintext highlighter-rouge">voxel_features</code> array at the position corresponding to the <code class="language-plaintext highlighter-rouge">voxel_ID</code>.</p>
  </li>
</ol>

<p>In summary, the Feature Extraction step processes <code class="language-plaintext highlighter-rouge">voxel_temp</code> data to calculate the average feature values for each voxel. This process is performed in parallel for all voxels, utilizing one thread per voxel. By the end of this step, the <code class="language-plaintext highlighter-rouge">voxel_features</code> array holds crucial information about each voxel’s characteristics in continuous memory, ready for further analysis and applications in point cloud processing. Each voxel’s information is stored in the <code class="language-plaintext highlighter-rouge">voxel_features</code> array at the position given by <code class="language-plaintext highlighter-rouge">voxel_ID</code>. For example we see feature extraction for the voxel at position 4 as shown in the Figure below.</p>

<div style="width: 80%;margin: 0 auto;">
<div class="row">
<div class="col-sm mt-3 mt-md-0 text-center">
    <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/feature_extract-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/feature_extract-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/feature_extract-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/feature_extract.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="hash table" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

</div>
</div>
<div class="caption">
     Feature Extraction :  Extract point features from voxel_temp array for every voxel and store the average in voxel_features array at it's voxel_ID. Here the features are (x,y) coordinates.
</div> 
</div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Voxel Feature Extraction for Voxel at Position 4

1. Prepare for Feature Extraction:
   We first initialize the num_points_per_voxel array to keep 
   track of the number of points in each voxel.
   For the voxel at position 4, num_points_per_voxel[4] = 2, as it contains two points.

2. Calculate Average Feature Values:
   We now iterate over the points in the voxel_temp array 
   for the voxel at position 4.Let's consider the features x and y 
   for this example.

   Iteration 1:
   - Point A: x = 2.9, y = 1.7
   - Sum of x = 2.9, Sum of y = 1.7

   Iteration 2:
   - Point B: x = 2.2, y = 1.3
   - Sum of x = 2.9 + 2.2 = 5.1, Sum of y = 1.7 + 1.3 = 3.0

3. Update Voxel Features:
   After iterating through all points in the voxel, we have the 
   sums of x and y for each feature.Now, we calculate the average by dividing
   the sum by the total number of points in the voxel (num_points_per_voxel[4] = 2).

   - Average x = 5.1 / 2 = 2.55
   - Average y = 3.0 / 2 = 1.5

   Finally, we update the voxel_features array for the voxel at position 4 with 
   the calculated average feature values: voxel_features[4] = (2.55, 1.5)

</code></pre></div></div>

<h2 id="4-inside-the-code">4. Inside the Code</h2>
<p>In this section, we will take a comprehensive look at the CUDA-powered voxelization implementation. We’ll dissect the code, step by step, to understand the magic behind its blazing-fast performance. To begin our exploration, let’s first setup and build the project locally and run the executable to see the CPU vs GPU performance. Then, we examine the folder structure that forms the foundation of this efficient voxelization engine. Understanding the organization of the code will serve as a solid starting point to grasp the inner workings of CUDA and its pivotal role in accelerating the voxelization process. So, let’s embark on this informative journey and unravel the secrets behind this powerful technique.</p>

<h4 id="41-setting-up-locally">4.1 Setting up Locally</h4>
<p>Before diving into the code, let’s set up the project locally by following these steps:
Setup Project Locally:</p>

<ol>
  <li>Install CUDA &gt; 11.1.</li>
  <li>Ensure you are using Ubuntu &gt; 18.04.</li>
  <li>Add CUDA path to <code class="language-plaintext highlighter-rouge">PATH</code> and <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>.</li>
  <li>OPTIONAL : PCL &gt; 1.8.1 ( Only for visualization)</li>
</ol>

<p>Now, let’s build and run the project with the provided commands:
<br></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/sanket-pixel/voxelize-cuda
<span class="nb">cd </span>voxelize-cuda
<span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake ..
make
./voxelize_cuda ../data/test/ <span class="nt">--cpu</span> 
</code></pre></div></div>
<p>You can expect an output similar to this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GPU has cuda devices: 1
----device id: 0 info----
  GPU : GeForce RTX 2060 
  Capbility: 7.5
  Global memory: 5912MB
  Const memory: 64KB
  SM in a block: 48KB
  warp size: 32
  threads in a block: 1024
  block dim: (1024,1024,64)
  grid dim: (2147483647,65535,65535)
-------------------------

Total 10
Average GPU Voxelization Time : 0.643269
Average CPU Voxelization Time : 374.432
Average GPU vs CPU Speedup : 582.076x times 

</code></pre></div></div>

<p>To start the visualization, make sure the PCL Library is installed before building. Then execute with <code class="language-plaintext highlighter-rouge">--visualize</code> flag.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./voxelize_cuda ../data/test/ <span class="nt">--visualize</span> 
</code></pre></div></div>
<p>Two windows will open up with titles <code class="language-plaintext highlighter-rouge">Point Cloud Viewer</code> and <code class="language-plaintext highlighter-rouge">Voxel Cloud Viewer</code> showing the original and voxelized point cloud respectively. Note that voxelized here means the point cloud after the feature extraction step. So the points represents the average of all points in each voxel.</p>

<p>To see detail logs of performance of every file, execute with <code class="language-plaintext highlighter-rouge">--verbose</code> flag.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./voxelize_cuda ../data/test/ <span class="nt">--verbose</span> 
</code></pre></div></div>

<p>By default the executable will just perform CUDA based Voxelization on GPU. To also perform voxelization
on the CPU, execute with the <code class="language-plaintext highlighter-rouge">--cpu</code> flag.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./voxelize_cuda ../data/test/ <span class="nt">--cpu</span> 
</code></pre></div></div>
<p>This will show time comparisions of CPU and GPU.</p>

<p>Once you have obtained this output, you can take a cup of coffee, as we are now ready to deep dive into the code. Let’s explore the implementation in detail.</p>

<h4 id="42-folder-structure">4.2. Folder structure</h4>

<p>The project directory contains the following files and folders:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ├── CMakeLists.txt
    ├── data
    │   └── test
    │       ├── pc1.bin
    │       └── pc2.bin
    |              .
    |              .
    |              .
    ├── include
    │   ├── common.h
    │   ├── kernel.h
    │   ├── visualizer.hpp
    │   ├── VoxelizerCPU.hpp
    │   └── VoxelizerGPU.h
    |   
    ├── main.cpp
    ├── README.md
    └── src
        ├── preprocess_kernel.cu
        ├── visualizer.cpp
        ├── VoxelizerCPU.cpp
        └── VoxelizerGPU.cpp
</code></pre></div></div>

<ul>
  <li>
<a href="#">CMakeLists.txt</a> - CMake configuration file for building the project</li>
  <li>
<strong>data</strong> - Directory containing test data used in the project.
    <ul>
      <li>
<strong>test</strong> - Subdirectory containing binary data files.</li>
    </ul>
  </li>
  <li>
<strong>include</strong> - Directory containing header files.
    <ul>
      <li>
<a href="#">common.h</a> - Header file with common definitions and macros.</li>
      <li>
<a href="#">kernel.h</a> - Header file with CUDA kernel function declarations.</li>
      <li>
<a href="#">visualizer.hpp</a> - Header file for Visualizer functions.</li>
      <li>
<a href="#">VoxelizerCPU.hpp</a> - Header file with CPU Voxelization functions</li>
      <li>
<a href="#">VoxelizerGPU.h</a> - Header file for the CUDA based Voxelization functions.</li>
    </ul>
  </li>
  <li>
<a href="#">main.cpp</a> - Main C++ source file that orchestrates the voxelization process.</li>
  <li>
<a href="#">README.md</a> - Markdown file containing project documentation and information.</li>
  <li>
<strong>src</strong> - Directory containing source files.
    <ul>
      <li>
<a href="#">preprocess_kernel.cu</a> - CUDA source file with kernel implementations.</li>
      <li>
<a href="#">visualizer.cpp</a> - Visualization function implementations.</li>
      <li>
<a href="#">VoxelizerCPU.cpp</a> - CPU Voxelization function implementations.</li>
      <li>
<a href="#">VoxelizerGPU.cpp</a> - GPU Voxelization function implementations.</li>
    </ul>
  </li>
</ul>

<h4 id="43-code-walkthrough">4.3 Code Walkthrough</h4>

<p>The main entry point of the program is the main function in the <code class="language-plaintext highlighter-rouge">main.cpp</code> file. It starts by checking the command-line arguments and loading the point cloud data from the specified folder.</p>

<h5 id="step-1-setup-and-initialization">Step 1: Setup and Initialization</h5>

<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">GetDeviceInfo</code> function is used to print information about the CUDA devices available on the system.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">getFolderFile</code> function is used to get a list of files in the specified data folder with a “.bin” extension.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">loadData</code> function is used to load the binary data file into memory.</p>
  </li>
</ul>

<h5 id="step-2-voxelization-cpu">Step 2: Voxelization CPU</h5>

<p>The CPU Voxelization is handled by the <code class="language-plaintext highlighter-rouge">VoxelizerCPU</code> class, defined in the <code class="language-plaintext highlighter-rouge">VoxelizerCPU.h</code> and <code class="language-plaintext highlighter-rouge">VoxelizerCPU.cpp</code> files.
It performs Voxelization on CPU using standard C++ operations.</p>

<h4 id="step-3-voxelization-gpu">Step 3: Voxelization GPU</h4>
<p>The CUDA based GPU Voxelization is handled by the <code class="language-plaintext highlighter-rouge">VoxelizerGPU</code> class, defined in the <code class="language-plaintext highlighter-rouge">VoxelizerGPU.h</code> and <code class="language-plaintext highlighter-rouge">VoxelizerGPU.cpp</code> files.
It performs Voxelization on GPU using CUDA kernels for Hash Map Building, Voxelization and Feature Extraction.</p>

<p><strong>A. Hash Map Building</strong>:</p>

<p>The hash map building is performed in the <code class="language-plaintext highlighter-rouge">buildHashKernel</code> CUDA kernel defined in the <code class="language-plaintext highlighter-rouge">preprocess_kernel.cu</code> file. This kernel takes the input point cloud data and converts it into voxel coordinates using the specified voxel size and range. It then builds a hash table that maps each <code class="language-plaintext highlighter-rouge">voxel_offset</code> to its corresponding <code class="language-plaintext highlighter-rouge">voxel_ID</code>.</p>

<p><strong>B. Voxelization</strong>:</p>

<p>The voxelization is performed in the <code class="language-plaintext highlighter-rouge">voxelizationKernel</code> CUDA kernel, also defined in the <code class="language-plaintext highlighter-rouge">preprocess_kernel.cu</code> file. This kernel uses the hash table built in the previous step to assign each point to its corresponding voxel. It counts the number of points in each voxel and stores them in the <code class="language-plaintext highlighter-rouge">num_points_per_voxel</code> array. It also serializes the point features for each voxel in the <code class="language-plaintext highlighter-rouge">voxels_temp</code> array.</p>

<p><strong>C. Feature Extraction</strong>:</p>

<p>The feature extraction is handled by the <code class="language-plaintext highlighter-rouge">featureExtractionKernel</code> CUDA kernel, also defined in the <code class="language-plaintext highlighter-rouge">preprocess_kernel.cu</code> file. This kernel takes the serialized point features in the <code class="language-plaintext highlighter-rouge">voxels_temp</code> array and computes the average feature values for each voxel. It stores the averaged features in the <code class="language-plaintext highlighter-rouge">voxel_features</code> array.</p>

<h4 id="step-4-output-and-cleanup">Step 4: Output and Cleanup</h4>

<p>After the Voxelization GPU is complete for all the input files, the program outputs the results and frees the allocated memory.</p>

<h4 id="44-deep-dive">4.4 Deep Dive</h4>
<p>Now that we have taken a closer look at the basic walkthrough of the code, let’s embark on a more comprehensive deep dive, exploring the intricacies of the CUDA kernels and delving into the inner workings of the preprocessor class. We will gradually progress from the core CUDA kernel, which handles the voxelization process efficiently through parallelism, to the preprocessor class, where these kernels are utilized. Finally, we will uncover how the main cpp file leverages the functionalities of the preprocessor class to apply voxelization on the input point cloud data, culminating in the generation of 3D voxels. This step-by-step approach will allow us to understand how each component contributes to the overall process and how they interact harmoniously to produce the desired output. So, let’s begin our journey from inside to out, unraveling the complexities of the code and gaining a deeper understanding of its functioning.</p>

<p><strong>1. CUDA Kernel for Building HashTables</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">buildHashKernel</code> is a CUDA kernel that performs the hash table building process. It takes the input point cloud data (<code class="language-plaintext highlighter-rouge">points</code>) and converts each point into voxel coordinates based on the specified voxel size and range. Then, it calls the <code class="language-plaintext highlighter-rouge">insertHashTable</code> function to insert each voxel offset as a key into the hash table, and the <code class="language-plaintext highlighter-rouge">real_voxel_num</code> variable is updated to keep track of the number of unique voxels in the hash table. The <code class="language-plaintext highlighter-rouge">buildHashKernel</code> function is executed by multiple CUDA threads in parallel, each processing a different point from the input point cloud. As a result, the hash table is efficiently built using GPU parallelism, and each voxel offset is uniquely assigned to an entry in the hash table.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">buildHashKernel</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">points</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">points_size</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">min_x_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_x_range</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">min_y_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_y_range</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">min_z_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_z_range</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">voxel_x_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">voxel_y_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">voxel_z_size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">grid_y_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">grid_x_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature_num</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hash_table</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">real_voxel_num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">point_idx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">point_idx</span> <span class="o">&gt;=</span> <span class="n">points_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kt">float</span> <span class="n">px</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">point_idx</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">py</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">point_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">pz</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">point_idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">px</span> <span class="o">&lt;</span> <span class="n">min_x_range</span> <span class="o">||</span> <span class="n">px</span> <span class="o">&gt;=</span> <span class="n">max_x_range</span> <span class="o">||</span> <span class="n">py</span> <span class="o">&lt;</span> <span class="n">min_y_range</span> <span class="o">||</span> <span class="n">py</span> <span class="o">&gt;=</span> <span class="n">max_y_range</span>
    <span class="o">||</span> <span class="n">pz</span> <span class="o">&lt;</span> <span class="n">min_z_range</span> <span class="o">||</span> <span class="n">pz</span> <span class="o">&gt;=</span> <span class="n">max_z_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_idx</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">px</span> <span class="o">-</span> <span class="n">min_x_range</span><span class="p">)</span> <span class="o">/</span> <span class="n">voxel_x_size</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_idy</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">py</span> <span class="o">-</span> <span class="n">min_y_range</span><span class="p">)</span> <span class="o">/</span> <span class="n">voxel_y_size</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_idz</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">pz</span> <span class="o">-</span> <span class="n">min_z_range</span><span class="p">)</span> <span class="o">/</span> <span class="n">voxel_z_size</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_offset</span> <span class="o">=</span> <span class="n">voxel_idz</span> <span class="o">*</span> <span class="n">grid_y_size</span> <span class="o">*</span> <span class="n">grid_x_size</span>
	                    <span class="o">+</span> <span class="n">voxel_idy</span> <span class="o">*</span> <span class="n">grid_x_size</span>
                            <span class="o">+</span> <span class="n">voxel_idx</span><span class="p">;</span>
  <span class="n">insertHashTable</span><span class="p">(</span><span class="n">voxel_offset</span><span class="p">,</span> <span class="n">real_voxel_num</span><span class="p">,</span> <span class="n">points_size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hash_table</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Here’s how the buildHashKernel works:</p>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__global__ void buildHashKernel(...)</code>: This line defines the <code class="language-plaintext highlighter-rouge">buildHashKernel</code> function as a CUDA kernel using the <code class="language-plaintext highlighter-rouge">__global__</code> function modifier. As a kernel, this function will be executed in parallel by multiple threads on the GPU.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int point_idx = blockIdx.x * blockDim.x + threadIdx.x</code>: This line calculates the index of the current point to be processed by the CUDA thread.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (point_idx &gt;= points_size) { return; }</code>: This condition checks if the thread index is out of bounds (i.e., beyond the number of points in the input points array). If so, the thread returns early to avoid processing invalid data.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">float px = points[feature_num * point_idx]; ...</code>: These lines extract the X, Y, and Z coordinates of the current point from the input points array based on the <code class="language-plaintext highlighter-rouge">feature_num</code> (the number of features per point).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (px &lt; min_x_range \|\| px &gt;= max_x_range \|\| ...</code>: This condition checks if the current point lies within the specified 3D range (min/max X, Y, Z). If the point is outside this range, it is not considered for voxelization, and the thread returns early.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int voxel_idx = floorf((px - min_x_range) / voxel_x_size); ...</code>: These lines calculate the voxel coordinates (<code class="language-plaintext highlighter-rouge">voxel_idx</code>, <code class="language-plaintext highlighter-rouge">voxel_idy</code>, <code class="language-plaintext highlighter-rouge">voxel_idz</code>) corresponding to the current point’s X, Y, and Z coordinates based on the specified voxel sizes and ranges.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int voxel_offset = voxel_idz * grid_y_size * grid_x_size ...</code>: This line calculates the <code class="language-plaintext highlighter-rouge">voxel_offset</code> based on the voxel coordinates. The <code class="language-plaintext highlighter-rouge">voxel_offset</code> is a flattened  index for each voxel within the 3D grid.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">insertHashTable(voxel_offset, real_voxel_num, points_size * 2 * 2, hash_table);</code>:  This line calls the <code class="language-plaintext highlighter-rouge">insertHashTable</code> function to insert the current <code class="language-plaintext highlighter-rouge">voxel_offset</code> into the hash table. It also updates the <code class="language-plaintext highlighter-rouge">real_voxel_num</code> variable using the <code class="language-plaintext highlighter-rouge">atomicAdd</code> function to keep track of the number of unique voxels added to the hash table.</p>
  </li>
</ol>

<p><strong>2. Inserting into HashTable</strong></p>

<p>Next, let’s move on to the <code class="language-plaintext highlighter-rouge">insertHashTable</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function to insert a key-value pair into the hash table</span>
<span class="n">__device__</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">insertHashTable</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">hash_size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">hash_table</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">hash_value</span> <span class="o">%</span> <span class="p">(</span><span class="n">hash_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="cm">/*key, value*/</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">empty_key</span> <span class="o">=</span> <span class="n">UINT32_MAX</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">pre_key</span> <span class="o">=</span> <span class="n">atomicCAS</span><span class="p">(</span><span class="n">hash_table</span> <span class="o">+</span> <span class="n">slot</span><span class="p">,</span> <span class="n">empty_key</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pre_key</span> <span class="o">==</span> <span class="n">empty_key</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">hash_table</span><span class="p">[</span><span class="n">slot</span> <span class="o">+</span> <span class="n">hash_size</span> <span class="o">/</span> <span class="mi">2</span> <span class="cm">/*offset*/</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pre_key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hash_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Explanation:</p>

<p>The <code class="language-plaintext highlighter-rouge">insertHashTable</code> function is responsible for inserting a key-value pair into the hash table. It uses the previously explained <code class="language-plaintext highlighter-rouge">hash</code> function to compute the hash value of the key, and then it resolves hash collisions using a technique called linear probing.</p>

<p>Here’s how the <code class="language-plaintext highlighter-rouge">insertHashTable</code> function works:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">uint64_t hash_value = hash(key)</code>: This line computes the hash value of the input <code class="language-plaintext highlighter-rouge">key</code> using the <code class="language-plaintext highlighter-rouge">hash</code> function.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">uint32_t slot = hash_value % (hash_size / 2)</code>: This line calculates the initial slot index in the hash table by taking the modulo of the hash value with half of the hash table size. This ensures that the slot index is within the valid range of the hash table.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">uint32_t empty_key = UINT32_MAX</code>: This line sets the <code class="language-plaintext highlighter-rouge">empty_key</code> variable to the maximum value of a 32-bit unsigned integer. This value is used to indicate an empty slot in the hash table.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">while (true) { ... }</code>: This is a loop that continues until the key is successfully inserted into the hash table. It handles hash collisions using linear probing.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">uint32_t pre_key = atomicCAS(hash_table + slot, empty_key, key)</code>: This line performs an atomic compare-and-swap operation (CAS) on the hash table. It checks if the slot at the current index (<code class="language-plaintext highlighter-rouge">slot</code>) is empty (i.e., contains <code class="language-plaintext highlighter-rouge">empty_key</code>). If it is empty, it atomically swaps the value with the input <code class="language-plaintext highlighter-rouge">key</code>, effectively inserting the key into the hash table.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (pre_key == empty_key) { ... }</code>: This condition checks if the CAS operation was successful, indicating that the key was inserted into the hash table. If successful, the function proceeds to update the offset in the hash table for the corresponding value (used in feature extraction).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hash_table[slot + hash_size / 2 /*offset*/] = atomicAdd(value, 1)</code>: This line atomically increments the value in the hash table at the offset <code class="language-plaintext highlighter-rouge">slot + hash_size / 2</code>, effectively storing the value for the given key. The <code class="language-plaintext highlighter-rouge">atomicAdd</code> function ensures that multiple threads trying to insert the same key concurrently will get unique values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">else if (pre_key == key) { ... }</code>: This condition handles the case when the slot already contains the same key (a duplicate). In this case, the function breaks out of the loop, as there’s no need to insert the key again.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">slot = (slot + 1) % (hash_size / 2)</code>: This line updates the slot index using linear probing by incrementing it by 1 and wrapping around to the beginning if it exceeds half of the hash table size.</p>
  </li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">insertHashTable</code> function plays a crucial role in building the hash table, which is later used in voxelization and feature extraction.</p>

<p><strong>3. Hash Function</strong></p>

<p>Sure, let’s start by explaining the base function, which is the <code class="language-plaintext highlighter-rouge">hash</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Hash function for generating a 64-bit hash value</span>
<span class="n">__device__</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">hash</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">k</span> <span class="o">^=</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">*=</span> <span class="mh">0x85ebca6b</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">^=</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">*=</span> <span class="mh">0xc2b2ae35</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">^=</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Explanation:</p>

<p>The <code class="language-plaintext highlighter-rouge">hash</code> function is a simple hash function that takes a 64-bit integer <code class="language-plaintext highlighter-rouge">k</code> as input and generates a 64-bit hash value using bitwise operations and multiplication with constants.</p>

<p>Here’s how the hash function works:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">k ^= k &gt;&gt; 16</code>: This line performs a bitwise XOR operation between <code class="language-plaintext highlighter-rouge">k</code> and <code class="language-plaintext highlighter-rouge">k</code> right-shifted by 16 bits. This step introduces a level of randomness to the bits.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">k *= 0x85ebca6b</code>: This line multiplies <code class="language-plaintext highlighter-rouge">k</code> by a constant value (<code class="language-plaintext highlighter-rouge">0x85ebca6b</code>). Multiplication helps in spreading out the bits and reducing collisions.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">k ^= k &gt;&gt; 13</code>: This line again performs a bitwise XOR operation between <code class="language-plaintext highlighter-rouge">k</code> and <code class="language-plaintext highlighter-rouge">k</code> right-shifted by 13 bits. This step further increases the randomness of the bits.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">k *= 0xc2b2ae35</code>: This line multiplies <code class="language-plaintext highlighter-rouge">k</code> by another constant value (<code class="language-plaintext highlighter-rouge">0xc2b2ae35</code>) to spread out the bits even more.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">k ^= k &gt;&gt; 16</code>: Finally, this line performs a bitwise XOR operation between <code class="language-plaintext highlighter-rouge">k</code> and <code class="language-plaintext highlighter-rouge">k</code> right-shifted by 16 bits. This step is the last step of mixing the bits to produce the final hash value.</p>
  </li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">hash</code> function is used in the hash table building process to generate unique hash values for the voxel offsets in the point cloud data.</p>

<p><strong>4. Voxelization Kernel</strong></p>

<p>In the voxelizationKernel CUDA kernel, each thread processes an individual point from the input point cloud. The goal of this function is to efficiently convert the points into their corresponding 3D voxel representations. It first calculates the voxel coordinates for each point based on the specified voxel sizes and ranges. Then, it uses a hash table lookup to find the corresponding voxel ID for each voxel offset. If the voxel ID is within the specified maximum number of voxels, the function atomically adds the point to the voxel and updates the voxel indices accordingly. This ensures a fast and optimized voxelization process for large and sparse point clouds.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">voxelizationKernel</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">points</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">points_size</span><span class="p">,</span>
                                   <span class="kt">float</span> <span class="n">min_x_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_x_range</span><span class="p">,</span>
                                   <span class="kt">float</span> <span class="n">min_y_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_y_range</span><span class="p">,</span>
                                   <span class="kt">float</span> <span class="n">min_z_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_z_range</span><span class="p">,</span>
                                   <span class="kt">float</span> <span class="n">voxel_x_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">voxel_y_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">voxel_z_size</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">grid_y_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">grid_x_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_voxels</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">max_points_per_voxel</span><span class="p">,</span>
                                   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hash_table</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_points_per_voxel</span><span class="p">,</span>
                                   <span class="kt">float</span> <span class="o">*</span><span class="n">voxels_temp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">voxel_indices</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">real_voxel_num</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="c1">// give every point to a thread. Find the index of the current point within this kernel.</span>
  <span class="kt">int</span> <span class="n">point_idx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">point_idx</span> <span class="o">&gt;=</span> <span class="n">points_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// points is the array of points in the point cloud storing point features (x, y, z, intensity, t)</span>
  <span class="c1">// in a serialized format. We access px, py, pz of this point now.</span>
  <span class="c1">// feature_num is 5, representing the number of features per point.</span>
  <span class="kt">float</span> <span class="n">px</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">point_idx</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">py</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">point_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">pz</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">point_idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

  <span class="c1">// If the point is outside the range along the (x, y, z) dimensions, stop further </span>
  <span class="c1">// processing and return.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">px</span> <span class="o">&lt;</span> <span class="n">min_x_range</span> <span class="o">||</span> <span class="n">px</span> <span class="o">&gt;=</span> <span class="n">max_x_range</span> <span class="o">||</span> <span class="n">py</span> <span class="o">&lt;</span> <span class="n">min_y_range</span> <span class="o">||</span> <span class="n">py</span> <span class="o">&gt;=</span> <span class="n">max_y_range</span>
    <span class="o">||</span> <span class="n">pz</span> <span class="o">&lt;</span> <span class="n">min_z_range</span> <span class="o">||</span> <span class="n">pz</span> <span class="o">&gt;=</span> <span class="n">max_z_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Now find the voxel id for this point using the usual voxel conversion logic.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_idx</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">px</span> <span class="o">-</span> <span class="n">min_x_range</span><span class="p">)</span> <span class="o">/</span> <span class="n">voxel_x_size</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_idy</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">py</span> <span class="o">-</span> <span class="n">min_y_range</span><span class="p">)</span> <span class="o">/</span> <span class="n">voxel_y_size</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_idz</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">pz</span> <span class="o">-</span> <span class="n">min_z_range</span><span class="p">)</span> <span class="o">/</span> <span class="n">voxel_z_size</span><span class="p">);</span>
  <span class="c1">// Now find the voxel offset, which is the index of the voxel if all voxels are flattened.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_offset</span> <span class="o">=</span> <span class="n">voxel_idz</span> <span class="o">*</span> <span class="n">grid_y_size</span> <span class="o">*</span> <span class="n">grid_x_size</span>
                            <span class="o">+</span> <span class="n">voxel_idy</span> <span class="o">*</span> <span class="n">grid_x_size</span>
                            <span class="o">+</span> <span class="n">voxel_idx</span><span class="p">;</span>
  <span class="c1">// We perform a scatter operation to voxels, and the result is stored in 'voxel_id'.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voxel_id</span> <span class="o">=</span> <span class="n">lookupHashTable</span><span class="p">(</span><span class="n">voxel_offset</span><span class="p">,</span> <span class="n">points_size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hash_table</span><span class="p">);</span>
  <span class="c1">// If the current voxel id is greater than max_voxels, simply return.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">voxel_id</span> <span class="o">&gt;=</span> <span class="n">max_voxels</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// With the voxel id, we can now atomically increment the counter for the number of points in the voxel.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_num</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">num_points_per_voxel</span> <span class="o">+</span> <span class="n">voxel_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// If the current number of points in the voxel exceeds the maximum allowed points per voxel, we return.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current_num</span> <span class="o">&gt;=</span> <span class="n">max_points_per_voxel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Now we can proceed to add the current point to the voxel's feature list.</span>
  <span class="c1">// Calculate the destination offset where the point's features will be stored in the voxels_temp array.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dst_offset</span> <span class="o">=</span> <span class="n">voxel_id</span> <span class="o">*</span> <span class="p">(</span><span class="n">feature_num</span> <span class="o">*</span> <span class="n">max_points_per_voxel</span><span class="p">)</span> <span class="o">+</span> <span class="n">current_num</span> <span class="o">*</span> <span class="n">feature_num</span><span class="p">;</span>
  <span class="c1">// Calculate the source offset of the current point's features in the points array.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_offset</span> <span class="o">=</span> <span class="n">point_idx</span> <span class="o">*</span> <span class="n">feature_num</span><span class="p">;</span>
  
  <span class="c1">// Copy the point's features from the points array to the corresponding location in the voxels_temp array.</span>
  <span class="c1">// This effectively adds the point's features to the voxel's feature list.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">feature_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">feature_idx</span> <span class="o">&lt;</span> <span class="n">feature_num</span><span class="p">;</span> <span class="o">++</span><span class="n">feature_idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">voxels_temp</span><span class="p">[</span><span class="n">dst_offset</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">src_offset</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">];</span>
  <span class="p">}</span>
  
  <span class="c1">// Store additional information about the voxel (its indices along X, Y, Z axes) for later processing.</span>
  <span class="n">uint4</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">voxel_idz</span><span class="p">,</span> <span class="n">voxel_idy</span><span class="p">,</span> <span class="n">voxel_idx</span><span class="p">};</span>
  <span class="p">((</span><span class="n">uint4</span> <span class="o">*</span><span class="p">)</span><span class="n">voxel_indices</span><span class="p">)[</span><span class="n">voxel_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Explanation:</p>

<p>Here’s how the <code class="language-plaintext highlighter-rouge">voxelizationKernel</code> works:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int point_idx = blockIdx.x * blockDim.x + threadIdx.x;</code>: This line calculates the index of the current point to be processed by the CUDA thread.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (point_idx &gt;= points_size) { return; }</code>: This condition checks if the thread index is out of bounds, i.e., beyond the number of points in the input points array. If so, the thread returns early to avoid processing invalid data.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">float px = points[feature_num * point_idx]; float py = points[feature_num * point_idx + 1]; float pz = points[feature_num * point_idx + 2];</code>: These lines extract the X, Y, and Z coordinates of the current point from the input points array based on the <code class="language-plaintext highlighter-rouge">feature_num</code> (the number of features per point).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (px &lt; min_x_range || px &gt;= max_x_range || py &lt; min_y_range || py &gt;= max_y_range || pz &lt; min_z_range || pz &gt;= max_z_range) { return; }</code>: This condition checks if the current point lies within the specified 3D range (min/max X, Y, Z). If the point is outside this range, it is not considered for voxelization, and the thread returns early.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int voxel_idx = floorf((px - min_x_range) / voxel_x_size); unsigned int voxel_idy = floorf((py - min_y_range) / voxel_y_size); unsigned int voxel_idz = floorf((pz - min_z_range) / voxel_z_size);</code>: These lines calculate the voxel coordinates (<code class="language-plaintext highlighter-rouge">voxel_idx</code>, <code class="language-plaintext highlighter-rouge">voxel_idy</code>, <code class="language-plaintext highlighter-rouge">voxel_idz</code>) corresponding to the current point’s X, Y, and Z coordinates based on the specified voxel sizes and ranges.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int voxel_offset = voxel_idz * grid_y_size * grid_x_size + voxel_idy * grid_x_size + voxel_idx;</code>: This line calculates the voxel offset based on the voxel coordinates. The voxel offset is a unique identifier for each voxel within the 3D grid.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int voxel_id = lookupHashTable(voxel_offset, points_size * 2 * 2, hash_table);</code>: This line calls the <code class="language-plaintext highlighter-rouge">lookupHashTable</code> function to find the corresponding voxel ID for the current voxel offset using the hash table.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (voxel_id &gt;= max_voxels) { return; }</code>: This condition checks if the current voxel ID is greater than or equal to <code class="language-plaintext highlighter-rouge">max_voxels</code>, indicating that the maximum number of allowed voxels has been reached. If so, the thread returns early.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int current_num = atomicAdd(num_points_per_voxel + voxel_id, 1);</code>: This line uses the <code class="language-plaintext highlighter-rouge">atomicAdd</code> function to atomically increment the number of points in the voxel represented by <code class="language-plaintext highlighter-rouge">voxel_id</code> in the <code class="language-plaintext highlighter-rouge">num_points_per_voxel</code> array.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">if (current_num &lt; max_points_per_voxel) { ... }</code>: This condition checks if the current number of points in the voxel is less than the maximum allowed per voxel. If so, the thread proceeds to add the current point’s features to the voxel.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unsigned int dst_offset = voxel_id * (feature_num * max_points_per_voxel) + current_num * feature_num; unsigned int src_offset = point_idx * feature_num;</code>: These lines calculate the offsets for copying the current point’s features to the voxel in the <code class="language-plaintext highlighter-rouge">voxels_temp</code> array.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">for (int feature_idx = 0; feature_idx &lt; feature_num; ++feature_idx) { voxels_temp[dst_offset + feature_idx] = points[src_offset + feature_idx]; }</code>: This loop copies the features of the current point to the appropriate location in the <code class="language-plaintext highlighter-rouge">voxels_temp</code> array, effectively adding the point to the voxel.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">uint4 idx = {0, voxel_idz, voxel_idy, voxel_idx}; ((uint4 *)voxel_indices)[voxel_id] = idx;</code>: These lines create an index vector (<code class="language-plaintext highlighter-rouge">idx</code>) containing information about the voxel’s position in the grid and store it in the <code class="language-plaintext highlighter-rouge">voxel_indices</code> array at the location corresponding to <code class="language-plaintext highlighter-rouge">voxel_id</code>. This allows quick lookup of voxel information during subsequent processing.</p>
  </li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">voxelizationKernel</code> efficiently assigns each point to its corresponding voxel, ensuring that points are appropriately added to the voxel’s feature list without exceeding the maximum allowed points per voxel.</p>

<p><strong>5. Voxelization Launch</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">voxelizationLaunch</code> function is a key step in the voxelization process. It is responsible for launching two CUDA kernels: <code class="language-plaintext highlighter-rouge">buildHashKernel</code> and <code class="language-plaintext highlighter-rouge">voxelizationKernel</code>. Let’s break down the function and its components:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cudaError_t</span> <span class="nf">voxelizationLaunch</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">points</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">points_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min_x_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_x_range</span><span class="p">,</span>
                          <span class="kt">float</span> <span class="n">min_y_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_y_range</span><span class="p">,</span><span class="kt">float</span> <span class="n">min_z_range</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_z_range</span><span class="p">,</span>
                          <span class="kt">float</span> <span class="n">voxel_x_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">voxel_y_size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">voxel_z_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">grid_y_size</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">grid_x_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_voxels</span><span class="p">,</span><span class="kt">int</span> <span class="n">max_points_per_voxel</span><span class="p">,</span>
                          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hash_table</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_points_per_voxel</span><span class="p">,</span><span class="kt">float</span> <span class="o">*</span><span class="n">voxel_features</span><span class="p">,</span> 
                          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">voxel_indices</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">real_voxel_num</span><span class="p">,</span> <span class="n">cudaStream_t</span> <span class="n">stream</span><span class="p">)</span> 
      <span class="p">{</span>
    <span class="c1">// how many threads in each block</span>
    <span class="kt">int</span> <span class="n">threadNum</span> <span class="o">=</span> <span class="n">THREADS_FOR_VOXEL</span><span class="p">;</span>
    <span class="c1">// how many blocks needed if each point gets on thread.</span>
    <span class="n">dim3</span> <span class="n">blocks</span><span class="p">((</span><span class="n">points_size</span><span class="o">+</span><span class="n">threadNum</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">threadNum</span><span class="p">);</span>
    <span class="c1">// how many threads in each block</span>
    <span class="n">dim3</span> <span class="n">threads</span><span class="p">(</span><span class="n">threadNum</span><span class="p">);</span>
    <span class="c1">// how many blocks needed to launch the kernel, how many threads in each block,</span>
    <span class="c1">// how many bytes for dynamic shared memory  ( zero here), cuda stream</span>
    <span class="n">buildHashKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="o">&gt;&gt;&gt;</span>
      <span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points_size</span><span class="p">,</span>
          <span class="n">min_x_range</span><span class="p">,</span> <span class="n">max_x_range</span><span class="p">,</span>
          <span class="n">min_y_range</span><span class="p">,</span> <span class="n">max_y_range</span><span class="p">,</span>
          <span class="n">min_z_range</span><span class="p">,</span> <span class="n">max_z_range</span><span class="p">,</span>
          <span class="n">voxel_x_size</span><span class="p">,</span> <span class="n">voxel_y_size</span><span class="p">,</span> <span class="n">voxel_z_size</span><span class="p">,</span>
          <span class="n">grid_y_size</span><span class="p">,</span> <span class="n">grid_x_size</span><span class="p">,</span> <span class="n">feature_num</span><span class="p">,</span> <span class="n">hash_table</span><span class="p">,</span>
    <span class="n">real_voxel_num</span><span class="p">);</span>
    <span class="n">voxelizationKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="o">&gt;&gt;&gt;</span>
      <span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points_size</span><span class="p">,</span>
          <span class="n">min_x_range</span><span class="p">,</span> <span class="n">max_x_range</span><span class="p">,</span>
          <span class="n">min_y_range</span><span class="p">,</span> <span class="n">max_y_range</span><span class="p">,</span>
          <span class="n">min_z_range</span><span class="p">,</span> <span class="n">max_z_range</span><span class="p">,</span>
          <span class="n">voxel_x_size</span><span class="p">,</span> <span class="n">voxel_y_size</span><span class="p">,</span> <span class="n">voxel_z_size</span><span class="p">,</span>
          <span class="n">grid_y_size</span><span class="p">,</span> <span class="n">grid_x_size</span><span class="p">,</span> <span class="n">feature_num</span><span class="p">,</span> <span class="n">max_voxels</span><span class="p">,</span>
          <span class="n">max_points_per_voxel</span><span class="p">,</span> <span class="n">hash_table</span><span class="p">,</span>
    <span class="n">num_points_per_voxel</span><span class="p">,</span> <span class="n">voxel_features</span><span class="p">,</span> <span class="n">voxel_indices</span><span class="p">,</span> <span class="n">real_voxel_num</span><span class="p">);</span>
    <span class="n">cudaError_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">cudaGetLastError</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Explanation:
Here’s how the <code class="language-plaintext highlighter-rouge">voxelizationLaunch</code> function works:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int threadNum = THREADS_FOR_VOXEL;</code>: This line sets the number of threads per block for the CUDA kernel. The value is obtained from the constant <code class="language-plaintext highlighter-rouge">THREADS_FOR_VOXEL</code>, which likely represents an optimal number of threads for efficient computation.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">dim3 blocks((points_size+threadNum-1)/threadNum);</code>: This line calculates the number of blocks needed to launch the kernel based on the total number of points (<code class="language-plaintext highlighter-rouge">points_size</code>) and the <code class="language-plaintext highlighter-rouge">threadNum</code>. It ensures that all points are processed by the threads efficiently.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">dim3 threads(threadNum);</code>: This line sets the number of threads in each block based on the previously calculated <code class="language-plaintext highlighter-rouge">threadNum</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">buildHashKernel&lt;&lt;&lt;blocks, threads, 0, stream&gt;&gt;&gt;(...)</code>: This line launches the <code class="language-plaintext highlighter-rouge">buildHashKernel</code> CUDA kernel. It processes the input points to build the hash table, which maps voxel offsets to voxel IDs.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">voxelizationKernel&lt;&lt;&lt;blocks, threads, 0, stream&gt;&gt;&gt;(...)</code>: This line launches the <code class="language-plaintext highlighter-rouge">voxelizationKernel</code> CUDA kernel. It voxelizes the input points based on the computed hash table, assigning points to corresponding voxels and storing the voxel features.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cudaError_t err = cudaGetLastError(); return err;</code>: These lines check for any errors that occurred during kernel launches. If there are any errors, they will be returned by the function, indicating a problem in the GPU computation.</p>
  </li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">voxelizationLaunch</code> function serves as the entry point to initiate the voxelization process on the GPU. It efficiently divides the data into blocks and threads, launches the necessary CUDA kernels (<code class="language-plaintext highlighter-rouge">buildHashKernel</code> and <code class="language-plaintext highlighter-rouge">voxelizationKernel</code>), and checks for any errors in the GPU computation. By effectively utilizing the GPU’s parallel processing capabilities, voxelization of large point clouds can be done efficiently and quickly.</p>

<p>Overall, the <code class="language-plaintext highlighter-rouge">voxelizationLaunch</code> function is a crucial step in the voxelization process, coordinating the parallel execution of the CUDA kernels to efficiently process and voxelate the input point cloud data.</p>

<p><strong>6. Feature Extraction Kernel</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">featureExtractionKernel</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">voxels_temp</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_points_per_voxel</span><span class="p">,</span>
                                        <span class="kt">int</span> <span class="n">max_points_per_voxel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature_num</span><span class="p">,</span> <span class="n">half</span> <span class="o">*</span><span class="n">voxel_features</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">voxel_idx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

    <span class="n">num_points_per_voxel</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_points_per_voxel</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_points_per_voxel</span> <span class="o">?</span>
                                      <span class="n">max_points_per_voxel</span> <span class="o">:</span> <span class="n">num_points_per_voxel</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">valid_points_num</span> <span class="o">=</span> <span class="n">num_points_per_voxel</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">voxel_idx</span> <span class="o">*</span> <span class="n">max_points_per_voxel</span> <span class="o">*</span> <span class="n">feature_num</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">feature_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">feature_idx</span> <span class="o">&lt;</span> <span class="n">feature_num</span><span class="p">;</span> <span class="o">++</span><span class="n">feature_idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">point_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">point_idx</span> <span class="o">&lt;</span> <span class="n">valid_points_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">point_idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">voxels_temp</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">voxels_temp</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">point_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">feature_num</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">voxels_temp</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">]</span> <span class="o">/=</span> <span class="n">valid_points_num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">feature_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">feature_idx</span> <span class="o">&lt;</span> <span class="n">feature_num</span><span class="p">;</span> <span class="o">++</span><span class="n">feature_idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">dst_offset</span> <span class="o">=</span> <span class="n">voxel_idx</span> <span class="o">*</span> <span class="n">feature_num</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">src_offset</span> <span class="o">=</span> <span class="n">voxel_idx</span> <span class="o">*</span> <span class="n">feature_num</span> <span class="o">*</span> <span class="n">max_points_per_voxel</span><span class="p">;</span>
        <span class="n">voxel_features</span><span class="p">[</span><span class="n">dst_offset</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">__float2half</span><span class="p">(</span><span class="n">voxels_temp</span><span class="p">[</span><span class="n">src_offset</span> <span class="o">+</span> <span class="n">feature_idx</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Here’s how the <code class="language-plaintext highlighter-rouge">featureExtractionKernel</code> works:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int voxel_idx = blockIdx.x * blockDim.x + threadIdx.x;</code>: This line calculates the index of the current voxel to be processed by the CUDA thread. Each CUDA thread corresponds to one voxel, and the <code class="language-plaintext highlighter-rouge">voxel_idx</code> uniquely identifies the voxel.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">num_points_per_voxel[voxel_idx] = num_points_per_voxel[voxel_idx] &gt; max_points_per_voxel ? max_points_per_voxel : num_points_per_voxel[voxel_idx];</code>: This line checks if the number of points in the current voxel exceeds the <code class="language-plaintext highlighter-rouge">max_points_per_voxel</code>. If it does, it clips the value to ensure that the feature extraction is performed on a maximum of <code class="language-plaintext highlighter-rouge">max_points_per_voxel</code> points for each voxel.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int valid_points_num = num_points_per_voxel[voxel_idx];</code>: This line retrieves the actual number of valid points in the current voxel, which may have been clipped in the previous step.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int offset = voxel_idx * max_points_per_voxel * feature_num;</code>: This line calculates the offset for accessing the voxel’s features in the <code class="language-plaintext highlighter-rouge">voxels_temp</code> array. It represents the index from which the current voxel’s features start in the <code class="language-plaintext highlighter-rouge">voxels_temp</code> array.</p>
  </li>
  <li>
    <p>The goal of feature extraction is to take the average for each feature (x, y, z, intensity, time) of every point in the voxel. The next few lines of code achieve this by iterating over each feature and each point in the voxel, summing up the feature values, and then dividing the sum by the number of valid points to obtain the average value.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">for (int feature_idx = 0; feature_idx &lt; feature_num; ++feature_idx) { ... }</code>: This loop iterates over each feature (x, y, z, intensity, time) and calculates the average value for that feature in the current voxel.</p>
  </li>
  <li>
    <p>The next loop within the feature extraction loop iterates over each point in the voxel (<code class="language-plaintext highlighter-rouge">point_idx</code>), starting from the second point (index 1) since the first point’s feature values were already added to <code class="language-plaintext highlighter-rouge">voxels_temp</code>.</p>
  </li>
  <li>
    <p>The feature values of each point are added to the corresponding feature in <code class="language-plaintext highlighter-rouge">voxels_temp</code>. After the loop, <code class="language-plaintext highlighter-rouge">voxels_temp[offset + feature_idx]</code> contains the sum of feature values for all points in the current voxel for the given feature.</p>
  </li>
  <li>
    <p>Finally, the sum for each feature is divided by the <code class="language-plaintext highlighter-rouge">valid_points_num</code> to calculate the average feature value for the current voxel. This average feature value is then stored in <code class="language-plaintext highlighter-rouge">voxels_temp</code> in the same location where the sum was stored earlier.</p>
  </li>
  <li>
    <p>The next loop moves the averaged voxel features from <code class="language-plaintext highlighter-rouge">voxels_temp</code> to the <code class="language-plaintext highlighter-rouge">voxel_features</code> array, ensuring that the features for each voxel are stored contiguously in <code class="language-plaintext highlighter-rouge">voxel_features</code>. The features are converted to the “half” data type (<code class="language-plaintext highlighter-rouge">__float2half</code>) for memory efficiency.</p>
  </li>
</ol>

<p>In summary, the <code class="language-plaintext highlighter-rouge">featureExtractionKernel</code> takes each voxel represented by a CUDA thread and calculates the average feature values (x, y, z, intensity, time) for all valid points in that voxel. The averaged voxel features are then stored in the <code class="language-plaintext highlighter-rouge">voxel_features</code> array, which represents the final output of the feature extraction process. The GPU’s parallel processing capabilities are utilized to efficiently perform this feature extraction on multiple voxels simultaneously, speeding up the overall computation for large point clouds.</p>

<p><strong>7. Feature Extraction Launch</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">cudaError_t</span> <span class="nf">featureExtractionLaunch</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">voxels_temp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_points_per_voxel</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">real_voxel_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_points_per_voxel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature_num</span><span class="p">,</span>
	<span class="n">half</span> <span class="o">*</span><span class="n">voxel_features</span><span class="p">,</span> <span class="n">cudaStream_t</span> <span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">threadNum</span> <span class="o">=</span> <span class="n">THREADS_FOR_VOXEL</span><span class="p">;</span>
  <span class="n">dim3</span> <span class="n">blocks</span><span class="p">((</span><span class="n">real_voxel_num</span> <span class="o">+</span> <span class="n">threadNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threadNum</span><span class="p">);</span>
  <span class="n">dim3</span> <span class="n">threads</span><span class="p">(</span><span class="n">threadNum</span><span class="p">);</span>
  <span class="n">featureExtractionKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="o">&gt;&gt;&gt;</span>
    <span class="p">(</span><span class="n">voxels_temp</span><span class="p">,</span> <span class="n">num_points_per_voxel</span><span class="p">,</span>
        <span class="n">max_points_per_voxel</span><span class="p">,</span> <span class="n">feature_num</span><span class="p">,</span> <span class="n">voxel_features</span><span class="p">);</span>
  <span class="n">cudaError_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">cudaGetLastError</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<p>The featureExtractionLaunch function is the launch function for the featureExtractionKernel, responsible for processing voxel data and extracting features. It takes the necessary input arrays, determines the block and thread configuration based on the number of voxels, launches the kernel, and captures any CUDA errors that might occur during execution.</p>

<p><strong>8.Generate Voxels</strong></p>

<p>This function in the <code class="language-plaintext highlighter-rouge">VoxelizerGPU.cpp</code> file is responsible for performing voxelization and feature extraction on a set of input points using CUDA on the GPU. Here’s how it works:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">VoxelizerGPU</span><span class="o">::</span><span class="n">generateVoxels</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">points</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">points_size</span><span class="p">,</span> <span class="n">cudaStream_t</span> <span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// flash memory for every run </span>
    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaMemsetAsync</span><span class="p">(</span><span class="n">hash_table_</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">hash_table_size_</span><span class="p">,</span> <span class="n">stream</span><span class="p">));</span>
    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaMemsetAsync</span><span class="p">(</span><span class="n">voxels_temp_</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">voxels_temp_size_</span><span class="p">,</span> <span class="n">stream</span><span class="p">));</span>

    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaMemsetAsync</span><span class="p">(</span><span class="n">d_voxel_num_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">voxel_num_size_</span><span class="p">,</span> <span class="n">stream</span><span class="p">));</span>
    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaMemsetAsync</span><span class="p">(</span><span class="n">d_real_num_voxels_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">stream</span><span class="p">));</span>
    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">));</span>

    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">voxelizationLaunch</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points_size</span><span class="p">,</span>
          <span class="n">params_</span><span class="p">.</span><span class="n">min_x_range</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">max_x_range</span><span class="p">,</span>
          <span class="n">params_</span><span class="p">.</span><span class="n">min_y_range</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">max_y_range</span><span class="p">,</span>
          <span class="n">params_</span><span class="p">.</span><span class="n">min_z_range</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">max_z_range</span><span class="p">,</span>
          <span class="n">params_</span><span class="p">.</span><span class="n">pillar_x_size</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">pillar_y_size</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">pillar_z_size</span><span class="p">,</span>
          <span class="n">params_</span><span class="p">.</span><span class="n">getGridYSize</span><span class="p">(),</span> <span class="n">params_</span><span class="p">.</span><span class="n">getGridXSize</span><span class="p">(),</span> <span class="n">params_</span><span class="p">.</span><span class="n">feature_num</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">max_voxels</span><span class="p">,</span>
          <span class="n">params_</span><span class="p">.</span><span class="n">max_points_per_voxel</span><span class="p">,</span> <span class="n">hash_table_</span><span class="p">,</span>
    <span class="n">d_voxel_num_</span><span class="p">,</span> <span class="cm">/*d_voxel_features_*/</span><span class="n">voxels_temp_</span><span class="p">,</span> <span class="n">d_voxel_indices_</span><span class="p">,</span>
    <span class="n">d_real_num_voxels_</span><span class="p">,</span> <span class="n">stream</span><span class="p">));</span>
    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">h_real_num_voxels_</span><span class="p">,</span> <span class="n">d_real_num_voxels_</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">,</span> <span class="n">stream</span><span class="p">));</span>
    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">));</span>

    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">featureExtractionLaunch</span><span class="p">(</span><span class="n">voxels_temp_</span><span class="p">,</span> <span class="n">d_voxel_num_</span><span class="p">,</span>
          <span class="o">*</span><span class="n">h_real_num_voxels_</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">max_points_per_voxel</span><span class="p">,</span> <span class="n">params_</span><span class="p">.</span><span class="n">feature_num</span><span class="p">,</span>
    <span class="n">d_voxel_features_</span><span class="p">,</span> <span class="n">stream</span><span class="p">));</span>

    <span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>Memory Initialization: The function starts by clearing the flash memory for each run. It uses <code class="language-plaintext highlighter-rouge">cudaMemsetAsync</code> to set the <code class="language-plaintext highlighter-rouge">hash_table_</code> and <code class="language-plaintext highlighter-rouge">voxels_temp_</code> memory regions to 0xFF asynchronously. It also sets the <code class="language-plaintext highlighter-rouge">d_voxel_num_</code> and <code class="language-plaintext highlighter-rouge">d_real_num_voxels_</code> memory regions to 0 asynchronously.</p>
  </li>
  <li>
    <p>Voxelization: Next, the function calls <code class="language-plaintext highlighter-rouge">voxelizationLaunch</code> with the input <code class="language-plaintext highlighter-rouge">points</code> array and various parameters such as <code class="language-plaintext highlighter-rouge">min_x_range</code>, <code class="language-plaintext highlighter-rouge">max_x_range</code>, <code class="language-plaintext highlighter-rouge">pillar_x_size</code>, <code class="language-plaintext highlighter-rouge">max_voxels</code>, etc. This function performs voxelization on the input points, generates a hash table to map voxel offsets to voxel IDs, and records the number of points per voxel in <code class="language-plaintext highlighter-rouge">d_voxel_num_</code>. The result is stored in <code class="language-plaintext highlighter-rouge">voxels_temp_</code>.</p>
  </li>
  <li>
    <p>Synchronization: After voxelization, the function synchronizes the CUDA stream to ensure that the previous kernel launch and memory operations are completed before proceeding.</p>
  </li>
  <li>
    <p>Feature Extraction: The function then calls <code class="language-plaintext highlighter-rouge">featureExtractionLaunch</code> with <code class="language-plaintext highlighter-rouge">voxels_temp_</code> and other related parameters. This function calculates the average of each feature (x, y, z, intensity, t) for each voxel and stores the results in the <code class="language-plaintext highlighter-rouge">d_voxel_features_</code> memory region using the <code class="language-plaintext highlighter-rouge">d_voxel_num_</code> information.</p>
  </li>
  <li>
    <p>Final Synchronization: Lastly, the function synchronizes the CUDA stream again to ensure all computations are completed, and then it returns 0 to indicate successful execution.</p>
  </li>
</ol>

<p>Overall, this function efficiently processes a large number of points by leveraging the parallel processing power of the GPU, leading to faster voxelization and feature extraction, crucial steps in point cloud processing and 3D data analysis.</p>

<p>This completes the code deep dive of all crucial components of performing Voxelization on GPU using CUDA Kernels. Now, in the next section, we will get some insights on the speed improvements provided by the GPU by comparing it with just CPU based Voxelization.</p>

<h2 id="5-conclusion">5. Conclusion</h2>

<p>We have already looked at how to make the executable perform Voxelization on both GPU and CPU. But let us revisit the command.
By default the executable will just perform CUDA based Voxelization on GPU. To also perform voxelization
on the CPU, execute with the <code class="language-plaintext highlighter-rouge">--cpu</code> flag.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./voxelize_cuda ../data/test/ <span class="nt">--cpu</span> 
</code></pre></div></div>

<p>The output of this command will looks something like this :</p>

<p>You can expect an output similar to this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GPU has cuda devices: 1
----device id: 0 info----
  GPU : GeForce RTX 2060 
  Capbility: 7.5
  Global memory: 5912MB
  Const memory: 64KB
  SM in a block: 48KB
  warp size: 32
  threads in a block: 1024
  block dim: (1024,1024,64)
  grid dim: (2147483647,65535,65535)
-------------------------

Total 10
Average GPU Voxelization Time : 0.643269
Average CPU Voxelization Time : 374.432
Average GPU vs CPU Speedup : 582.076x times 

</code></pre></div></div>

<div style="width: 100%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_2/elon.gif-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_2/elon.gif-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_2/elon.gif-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_2/elon.gif" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
What getting 580x times speedup feels like.
</div>
</div>

<p>Let than sink in for a moment. The GPU-based Voxelization, driven by the incredible CUDA programming, has showcased an astronomical performance boost of over 580 times compared to the traditional CPU approach. It’s like witnessing a swift and majestic leap from a snail’s pace to warp speed travel. The difference is staggering. To put this into perspective, if this process took 1 second for the GPU using CUDA programming, it would take around 10 minutes for the same process on the CPU. This is what 580x time means.</p>

<p>The potential of CUDA programming is awe-inspiring and goes far beyond just voxelization. These concepts open doors to a world of possibilities in diverse fields. Whether it’s 3D detection, medical imaging, simulations, or artificial intelligence, CUDA unleashes a new dimension of coding brilliance.</p>

<p>So, fasten your seatbelts as you venture into the thrilling realm of CUDA programming. Embrace the power and speed it offers, and watch your code transform into a force to be reckoned with. Sure, the journey might have its challenges, but the jaw-dropping speedup you’ll achieve is absolutely worth the effort.</p>

<p>With CUDA, the sky is no longer the limit; it’s just the beginning. So go forth and conquer the universe of parallel programming! 🚀💻</p>

<p>That concludes our exhilarating exploration of GPU-based Voxelization using CUDA. Happy coding, and may your adventures in parallel programming be as thrilling as this one!</p>


    </div>
  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/that-first-cuda-blog/">That First CUDA Blog I Needed</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/hidden-speed-in-shared-memory-copy/">Hidden Speed in CUDA's Shared Memory</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/a-practical-guide-to-quantization/">A practical guide to Quantization</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/down-the-cudamemory-lane/">Down the CudaMemory lane</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/quantization-explained-like-youre-five/">Quantization explained, like you are five.</a>
  </li>

</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Sanket R. Shah. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
