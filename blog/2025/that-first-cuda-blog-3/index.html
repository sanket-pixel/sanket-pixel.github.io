<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>That First CUDA Blog I Needed :Part 3 | Sanket Shah</title>
    <meta name="author" content="Sanket R. Shah">
    <meta name="description" content="Solving a Real World Problem with CUDA">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://sanket-pixel.github.io//blog/2025/that-first-cuda-blog-3/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-J2Z5HX2M1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-J2Z5HX2M1E');
  </script>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/">Sanket Shah</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">That First CUDA Blog I Needed :Part 3</h1>
    <p class="post-meta">May 31, 2025</p>
    <p class="post-tags">
      <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>
        ·  
        <a href="/blog/tag/nvidia">
          <i class="fas fa-hashtag fa-sm"></i> nvidia</a>  
          <a href="/blog/tag/cuda">
          <i class="fas fa-hashtag fa-sm"></i> cuda</a>  
          
        ·  
        <a href="/blog/category/cuda">
          <i class="fas fa-tag fa-sm"></i> cuda</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <p>In the previous part of this blog, <a href="/blog/2025/that-first-cuda-blog-2">Part 2: Building Blocks of Parallelism</a>, we explored how CUDA organizes threads into blocks and grids, and how memory is managed between the CPU and GPU. That gave us the tools. Now, in Part 3, we bring it all together in a real CUDA project — processing an image on the GPU, handling real-world memory issues, and learning from common beginner mistakes.</p>

<p><br></p>
<div style="width: 90%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/uni-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/uni-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/uni-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/uni.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="latency compare" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
   Part 3 : Graduating in CUDA 
</div>
</div>

<h5 id="part-3-a-real-world-cuda-project"><a href="/blog/2025/that-first-cuda-blog-3">Part 3: A Real-World CUDA Project</a></h5>
<p><a href="/blog/2025/that-first-cuda-blog-3#6-your-first-real-cuda-example-grayscale-conversion">6. Your First Real CUDA Example: Grayscale Conversion</a><br>
<a href="/blog/2025/that-first-cuda-blog-3#7-common-pitfalls-when-getting-started">7. Common Pitfalls When Getting Started</a><br>
<a href="/blog/2025/that-first-cuda-blog-3#8-thats-a-wrap-now-youre-cuda-capable">8. That’s a Wrap — Now You’re CUDA-Capable</a></p>

<blockquote>
  <p>All the code related to this blog series, accompanying each step of your CUDA learning journey, can be found on GitHub at: <a href="https://github.com/sanket-pixel/blog_code/tree/main/8_that_first_cuda_blog" rel="external nofollow noopener" target="_blank">https://github.com/sanket-pixel/blog_code/tree/main/8_that_first_cuda_blog</a>.</p>
</blockquote>

<h3 id="6-your-first-real-cuda-example-grayscale-conversion"><strong>6. Your First Real CUDA Example: Grayscale Conversion</strong></h3>
<p>We’ve now covered key CUDA concepts like thread organization, memory management, and kernel launches, and written several simple toy kernels to make them stick. It’s time to take off the training wheels and write a full CUDA kernel to solve a real-world problem.</p>

<p>In this next section, we’ll convert a color image to grayscale — not one pixel at a time like we would on the CPU, but all at once by leveraging CUDA’s parallel threads. It’s a practical use case that brings everything we’ve learned together. Let us first look at the code and run it locally to convert a sample color image to grayscale.</p>

<div style="width: 90%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/gray.svg-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/gray.svg-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/gray.svg-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/gray.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="matrix" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
Converting colored image to grayscale using CUDA
</div>
</div>

<h5 id="61-understanding-image-data-rgb-grayscale-and-memory-layout"><strong>6.1 Understanding Image Data: RGB, Grayscale, and Memory Layout</strong></h5>
<p>Before we dive into writing a CUDA kernel for image processing, we need to understand how image data is actually stored in memory. This section provides a foundational overview for readers who are comfortable with programming but new to image manipulation.</p>

<p>Most color images use the RGB format, where each pixel consists of three values: <strong>red intensity, green intensity, and blue intensity</strong>. Each of these values typically occupies <code class="language-plaintext highlighter-rouge">1 byte (0–255)</code>, meaning a single RGB pixel takes up 3 bytes in memory. In the image below, the pixels marked A, B, and C each represent such RGB triplets, with their respective red, green, and blue components visualized. This structure forms the foundation of how color is encoded and stored in digital images — each pixel is just a tiny combination of three color intensities.</p>

<div style="width: 90%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/rgb.svg-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/rgb.svg-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/rgb.svg-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/rgb.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="matrix" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
Each pixel (A, B, C) stores color using three values — red, green, and blue — forming an RGB triplet.
</div>
</div>

<p>If the image has a width of <code class="language-plaintext highlighter-rouge">W</code> and a height of <code class="language-plaintext highlighter-rouge">H</code>, then the RGB image is stored in memory as a 1D array of size <code class="language-plaintext highlighter-rouge">H x W x 3</code>. The storage is typically <em>row-major</em>, meaning we store pixels row by row. For example, the first row’s pixels come first, then the second row’s, and so on.</p>

<p>For a <code class="language-plaintext highlighter-rouge">3×2</code> image<code class="language-plaintext highlighter-rouge">(3 columns, 2 rows)</code>, the RGB memory layout looks like this:</p>

<div style="width: 70%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/pixels.svg-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/pixels.svg-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/pixels.svg-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/pixels.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="matrix" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
</div>

<p>This is flattened into a 1D array as:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[R00, G00, B00, R01, G01, B01, R02, G02, B02, R10, G10, B10, R11, G11, B11, R12, G12, B12]
</code></pre></div></div>
<p>To locate the RGB triplet for a pixel at <code class="language-plaintext highlighter-rouge">(row, col)</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">r</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">g</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
</code></pre></div></div>

<p>A grayscale image stores only one intensity value per pixel — no color, just brightness. This simplifies both the memory and computation.
For the same <code class="language-plaintext highlighter-rouge">3×2 image</code>, a grayscale layout would be:</p>
<div style="width: 60%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/graypixel.svg-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/graypixel.svg-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/graypixel.svg-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/graypixel.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="matrix" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
</div>
<p>Flattened memory:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[P00, P01, P02, P10, P11, P12]
</code></pre></div></div>
<p>Only one byte per pixel is stored, and the total memory size is <code class="language-plaintext highlighter-rouge">HxW</code> bytes. To access the grayscale value for a pixel at <code class="language-plaintext highlighter-rouge">(row, col)</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</code></pre></div></div>
<p>The grayscale intensity <code class="language-plaintext highlighter-rouge">P</code> for an RGB pixel is typically calculated using the following weighted average:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="mf">0.299</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">G</span> <span class="o">+</span> <span class="mf">0.114</span> <span class="o">*</span> <span class="n">B</span>
</code></pre></div></div>
<p>This formula accounts for human visual sensitivity to different colors and is widely used in image processing.<br>
This basic understanding of how pixel data is organized in memory sets the stage for the CUDA implementation in the next section, where each GPU thread will process one pixel at a time — reading its RGB triplet, converting it to grayscale, and writing the result into the output buffer.</p>

<h5 id="62-converting-rgb-to-grayscale-in-cuda"><strong>6.2 Converting RGB to Grayscale in CUDA</strong></h5>
<p>In this next section, we’ll convert a color image to grayscale — not one pixel at a time like we would on the CPU, but all at once by leveraging CUDA’s parallel threads. It’s a practical use case that brings everything we’ve learned together. Let us first look at the code and run it locally to convert a sample color image to grayscale.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cuda.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp">
#define BLOCKSIZE_X 32
#define BLOCKSIZE_Y 32
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">convert_rgb_to_grayscale</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">dsample_image</span><span class="p">,</span>
                                         <span class="kt">float</span> <span class="o">*</span><span class="n">dgrayscale_sample_image</span><span class="p">,</span>
                                         <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// compute the (x, y) coordinates of the thread in the image</span>
  <span class="kt">int</span> <span class="n">global_x</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">global_y</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

  <span class="c1">// check that we are within image bounds</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">global_x</span> <span class="o">&lt;</span> <span class="n">cols</span> <span class="o">&amp;&amp;</span> <span class="n">global_y</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// flatten 2D coordinates into a 1D index</span>
    <span class="kt">int</span> <span class="n">global_id</span> <span class="o">=</span> <span class="n">global_y</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">global_x</span><span class="p">;</span>

    <span class="c1">// fetch the RGB values for the current pixel</span>
    <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">dsample_image</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">global_id</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">dsample_image</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">global_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">dsample_image</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">global_id</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

    <span class="c1">// compute grayscale using weighted sum (perceptual luminance)</span>
    <span class="n">dgrayscale_sample_image</span><span class="p">[</span><span class="n">global_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.144</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">g</span> <span class="o">+</span> <span class="mf">0.299</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// read image from filepath</span>
  <span class="n">string</span> <span class="n">sample_image_path</span> <span class="o">=</span> <span class="s">"../sample.png"</span><span class="p">;</span>
  <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">sample_image</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">sample_image_path</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span>
  <span class="n">sample_image</span><span class="p">.</span><span class="n">convertTo</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">);</span>

  <span class="c1">// allocate memory on GPU</span>
  <span class="kt">int</span> <span class="n">sample_image_size_in_bytes</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">channels</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
  <span class="kt">float</span> <span class="o">*</span><span class="n">dsample_image</span><span class="p">;</span>
  <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsample_image</span><span class="p">,</span> <span class="n">sample_image_size_in_bytes</span><span class="p">);</span>
  <span class="c1">// allocate memory on GPU to store the grayscale image</span>
  <span class="kt">float</span> <span class="o">*</span><span class="n">dgrayscale_sample_image</span><span class="p">;</span>
  <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dgrayscale_sample_image</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

  <span class="c1">// copy image from CPU to GPU</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">dsample_image</span><span class="p">,</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_image_size_in_bytes</span><span class="p">,</span>
             <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

  <span class="c1">// compute number of blocks in x and y dimensions</span>
  <span class="kt">int</span> <span class="n">number_of_blocks_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">BLOCKSIZE_X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCKSIZE_X</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">number_of_blocks_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="n">BLOCKSIZE_Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCKSIZE_Y</span><span class="p">;</span>
  <span class="c1">// define grid dimension and block dimension for kernel launch</span>
  <span class="n">dim3</span> <span class="n">grid_dim</span><span class="p">(</span><span class="n">number_of_blocks_x</span><span class="p">,</span> <span class="n">number_of_blocks_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">dim3</span> <span class="n">block_dim</span><span class="p">(</span><span class="n">BLOCKSIZE_X</span><span class="p">,</span> <span class="n">BLOCKSIZE_Y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="c1">// launch the kernel</span>
  <span class="n">convert_rgb_to_grayscale</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_dim</span><span class="p">,</span> <span class="n">block_dim</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
      <span class="n">dsample_image</span><span class="p">,</span> <span class="n">dgrayscale_sample_image</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>


  <span class="c1">// copy the grayscale image back from GPU to CPU</span>
  <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">himage_grayscale</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>
  <span class="kt">float</span> <span class="o">*</span><span class="n">himage_grayscale_data</span> <span class="o">=</span>
      <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">float</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">himage_grayscale</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">himage_grayscale_data</span><span class="p">,</span> <span class="n">dgrayscale_sample_image</span><span class="p">,</span>
             <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
  <span class="n">himage_grayscale</span><span class="p">.</span><span class="n">convertTo</span><span class="p">(</span><span class="n">himage_grayscale</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="mf">255.0</span><span class="p">);</span>
  <span class="n">cv</span><span class="o">::</span><span class="n">imwrite</span><span class="p">(</span><span class="s">"../grayscale_sample.png"</span><span class="p">,</span> <span class="n">himage_grayscale</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To execute this program on your machine, follow the following steps :</p>

<ol>
  <li>Navigate to the directory <em>8_that_first_cuda_blog/4_grayscale_2d</em>
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>8_that_first_cuda_blog/4_grayscale_2d
</code></pre></div>    </div>
  </li>
  <li>Make a <code class="language-plaintext highlighter-rouge">build</code> directory and navigate into it
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
</code></pre></div>    </div>
  </li>
  <li>Generate the Makefile. Specify the appropriate CUDA path
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>cmake .. <span class="nt">-DCMAKE_CUDA_COMPILER</span><span class="o">=</span>/usr/local/cuda-12.1/bin/nvcc
</code></pre></div>    </div>
  </li>
  <li>Compile the program using the following command
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>make
</code></pre></div>    </div>
  </li>
  <li>This will create an executable <code class="language-plaintext highlighter-rouge">grayscale_2d</code> in the <code class="language-plaintext highlighter-rouge">build</code> directory. Execute it using
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>./grayscale_2d
</code></pre></div>    </div>
  </li>
  <li>The grayscale image will be stored in the <em>8_that_first_cuda_blog/4_grayscale_2d</em> folder as <code class="language-plaintext highlighter-rouge">grayscale_sample.png</code>
</li>
</ol>

<p>If all went well, you just wrote your first real and useful CUDA kernel. In essence, the code above does the following:</p>
<ol>
  <li>We loaded a color image using OpenCV and converted its pixel values to floats.</li>
  <li>We allocated memory on the GPU for both the input image and the grayscale output.</li>
  <li>We copied the image data from the CPU to the GPU.</li>
  <li>We calculated how many blocks and threads we need to cover all pixels—each block handles a small tile of the image, and each thread processes one pixel.</li>
  <li>The CUDA kernel ran in parallel, where each thread took one pixel and computed the grayscale value as a weighted sum of its R, G, B components.</li>
  <li>Finally, we copied the grayscale result back to the CPU and saved it as an image file.</li>
</ol>

<div style="width: 90%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/flow.svg-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/flow.svg-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/flow.svg-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/flow.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="matrix" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
</div>

<p>Let us look at the above code, one crucial part at a time.</p>

<ul>
  <li>Firstly, we read the image using <code class="language-plaintext highlighter-rouge">OpenCV</code>, extract the <code class="language-plaintext highlighter-rouge">width</code>,<code class="language-plaintext highlighter-rouge">height</code> and <code class="language-plaintext highlighter-rouge">channels</code>.</li>
  <li>By default, OpenCV loads the image in <code class="language-plaintext highlighter-rouge">int8</code> format. We convert it to <code class="language-plaintext highlighter-rouge">float32</code> for ease of processing. <br>
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// read image from filepath</span>
<span class="n">string</span> <span class="n">sample_image_path</span> <span class="o">=</span> <span class="s">"../sample.png"</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">sample_image</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">sample_image_path</span><span class="p">);</span> <span class="c1">// read the image</span>
<span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="c1">// extract height, width, channels</span>
<span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span>
<span class="n">sample_image</span><span class="p">.</span><span class="n">convertTo</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">);</span> <span class="c1">// convert the image from int8 to float32</span>
</code></pre></div>    </div>
    <p>The details of OpenCV and its interfaces are beyond the scope of this blog post. 
For our purposes, it is enough to understand that the code above simply loads the image into CPU memory in a row-major, contiguous format.</p>
  </li>
  <li>We then calculate how much memory the image will occupy in bytes <code class="language-plaintext highlighter-rouge">(width × height × channels × sizeof(float))</code>.</li>
  <li>Then we allocate that much space on the GPU using <code class="language-plaintext highlighter-rouge">cudaMalloc</code>.</li>
  <li>We copy the image data from the CPU (<code class="language-plaintext highlighter-rouge">sample_image.data</code>) to the allocated GPU memory (<code class="language-plaintext highlighter-rouge">dsample_image</code>) using cudaMemcpy.
This ensures that the image is now available on the GPU for parallel processing.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sample_image_size_in_bytes</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">channels</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="kt">float</span> <span class="o">*</span><span class="n">dsample_image</span><span class="p">;</span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsample_image</span><span class="p">,</span> <span class="n">sample_image_size_in_bytes</span><span class="p">);</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">dsample_image</span><span class="p">,</span> <span class="n">sample_image</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_image_size_in_bytes</span><span class="p">,</span>
        <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">dsample_image</code> is the pointer to the input RGB image, and <code class="language-plaintext highlighter-rouge">dgrayscale_sample_image</code> is the pointer to the output grayscale image.
We pass pointers because CUDA kernels operate on data already present on the GPU — they don’t copy data themselves.</li>
  <li>We also pass the image dimensions (<code class="language-plaintext highlighter-rouge">rows</code> and <code class="language-plaintext highlighter-rouge">cols</code>) so that each thread can figure out which pixel it is responsible for.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">__global__</span> <span class="kt">void</span> <span class="n">convert_rgb_to_grayscale</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">dsample_image</span><span class="p">,</span>
                                       <span class="kt">float</span> <span class="o">*</span><span class="n">dgrayscale_sample_image</span><span class="p">,</span>
                                       <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Each GPU thread is assigned a unique (x, y) coordinate using its block and thread indices.</li>
  <li>It checks whether this coordinate lies within the bounds of the image to avoid illegal memory access.</li>
  <li>Using the 2D coordinate, it calculates a flat 1D index to access the RGB values of that pixel.</li>
  <li>Finally, it computes the grayscale value using a weighted sum and writes it to the output array on the GPU.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global_x</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">global_y</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">global_x</span> <span class="o">&lt;</span> <span class="n">cols</span> <span class="o">&amp;&amp;</span> <span class="n">global_y</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">global_id</span> <span class="o">=</span> <span class="n">global_y</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">global_x</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">dsample_image</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">global_id</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">dsample_image</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">global_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">dsample_image</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">global_id</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
<span class="n">dgrayscale_sample_image</span><span class="p">[</span><span class="n">global_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.144</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">g</span> <span class="o">+</span> <span class="mf">0.299</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>We calculate how many blocks are needed in the X and Y directions to cover the entire image, rounding up to handle any leftover pixels.</li>
  <li>Each block contains a fixed number of threads defined by <code class="language-plaintext highlighter-rouge">BLOCKSIZE_X</code> and <code class="language-plaintext highlighter-rouge">BLOCKSIZE_Y</code>.</li>
  <li>These values are used to create the grid and block dimensions (<code class="language-plaintext highlighter-rouge">grid_dim</code> and <code class="language-plaintext highlighter-rouge">block_dim</code>), which tell CUDA how to organize threads for parallel execution.</li>
  <li>Finally, we launch the kernel with this configuration, passing the GPU pointers and image dimensions so each thread can process its assigned pixel.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// compute number of blocks in x and y dimensions</span>
<span class="kt">int</span> <span class="n">number_of_blocks_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">BLOCKSIZE_X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCKSIZE_X</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">number_of_blocks_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="n">BLOCKSIZE_Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCKSIZE_Y</span><span class="p">;</span>
<span class="c1">// define grid dimension and block dimension for kernel launch</span>
<span class="n">dim3</span> <span class="nf">grid_dim</span><span class="p">(</span><span class="n">number_of_blocks_x</span><span class="p">,</span> <span class="n">number_of_blocks_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dim3</span> <span class="nf">block_dim</span><span class="p">(</span><span class="n">BLOCKSIZE_X</span><span class="p">,</span> <span class="n">BLOCKSIZE_Y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// launch the kernel</span>
<span class="n">convert_rgb_to_grayscale</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_dim</span><span class="p">,</span> <span class="n">block_dim</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
  <span class="n">dsample_image</span><span class="p">,</span> <span class="n">dgrayscale_sample_image</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>We create an empty OpenCV matrix <code class="language-plaintext highlighter-rouge">himage_grayscale</code> on the CPU to hold the grayscale image data and get a raw pointer to its data.</li>
  <li>Then, we copy the grayscale image from GPU memory back to the CPU, convert it to an 8-bit format, and save it as a PNG file using OpenCV’s <code class="language-plaintext highlighter-rouge">imwrite</code>.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// copy the grayscale image back from GPU to CPU</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="nf">himage_grayscale</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>
<span class="kt">float</span> <span class="o">*</span><span class="n">himage_grayscale_data</span> <span class="o">=</span>
  <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">float</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">himage_grayscale</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">himage_grayscale_data</span><span class="p">,</span> <span class="n">dgrayscale_sample_image</span><span class="p">,</span>
          <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">himage_grayscale</span><span class="p">.</span><span class="n">convertTo</span><span class="p">(</span><span class="n">himage_grayscale</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="mf">255.0</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imwrite</span><span class="p">(</span><span class="s">"../grayscale_sample.png"</span><span class="p">,</span> <span class="n">himage_grayscale</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>And with that, we complete converting an colored image to grayscale using CUDA as shown below. Each pixel is processed by one thread, in parallel on the GPU.</p>

<div style="width: 90%;margin: 0 auto;">
<div class="row">
    <div class="col-sm mt-3 mt-md-0 text-center"> <!-- Add 'text-center' class here -->
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/blog_8/gray.svg-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/blog_8/gray.svg-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/blog_8/gray.svg-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/blog/blog_8/gray.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="matrix" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<div class="caption">
Left : Colored input image Right : Grayscale output image
</div>
</div>

<h3 id="7-common-pitfalls-when-getting-started"><strong>7. Common Pitfalls When Getting Started</strong></h3>
<p>Even with the basics in place, beginners often run into a few predictable issues when working with CUDA for the first time. Here are some of the most common ones to watch out for:</p>

<p><strong>Threads are not sequential</strong>
Just because you launch threads with increasing indices (threadIdx.x = 0, 1, 2…) doesn’t mean they run in that order. Threads execute in parallel, and their actual scheduling is unpredictable. Don’t write code that assumes a specific order of execution.</p>

<p><strong>Thread limit per block</strong>
The maximum number of threads per block is typically 1024. If you accidentally set a higher block dimension (say, blockDim.x = 2048), the kernel will silently fail or produce garbage results—often all zeros. Always check that your block configuration respects this hardware limit.</p>

<p><strong>Not syncing when CPU depends on GPU</strong>
CUDA kernel launches are asynchronous. If your CPU code depends on the GPU result right after a kernel call, you must call cudaDeviceSynchronize() to wait for GPU completion before using the data.</p>

<p><strong>Mixing up grid and block indices</strong>
It’s easy to confuse blockIdx and threadIdx, or miscalculate global thread IDs. Always double-check your formulas when computing pixel indices or array offsets.</p>

<p><strong>Forgetting to check memory copies</strong>
Many issues arise from not copying data to or from the GPU at the right time. Use cudaMemcpy() carefully and verify its direction (cudaMemcpyHostToDevice vs. DeviceToHost).</p>

<p><strong>Uninitialized or out-of-bounds memory</strong>
Accessing memory outside the range of your arrays won’t throw an error—it just causes silent corruption or crashes. Always make sure your thread doesn’t go beyond valid bounds, especially when using 2D grids or blocks.</p>

<p><strong>Kernel launch succeeds but does nothing</strong>
A kernel that silently does nothing can happen due to:</p>
<ul>
  <li>Launching with zero threads.</li>
  <li>All threads exiting early due to an if condition.</li>
  <li>Threads writing to out-of-bounds memory.</li>
  <li>Use cudaGetLastError() to check for launch issues.</li>
</ul>

<h3 id="8-thats-a-wrap-now-youre-cuda-capable"><strong>8. That’s a Wrap: Now You’re CUDA-Capable</strong></h3>
<p>If you made it this far, you’ve already done more than most who skim CUDA docs and bounce off. The goal wasn’t to turn you into a GPU performance wizard overnight — it was to flip the mental switch. To make CUDA feel a little less alien.</p>

<p>We didn’t chase shared memory or benchmark numbers. We stayed grounded — loading an image, writing a basic kernel, seeing how threads work, and gently peeling back the hardware layers. And that’s enough. Because <em>truly understanding one kernel end to end</em> teaches you more than stitching together code from Stack Overflow.</p>

<p>The truth is, you’ll forget the exact syntax. You might mix up <code class="language-plaintext highlighter-rouge">threadIdx</code> and <code class="language-plaintext highlighter-rouge">blockIdx</code> next week. But what stays is the <em>shape</em> of the model: blocks, threads, grids — and how they map to real computation. That shape is what lets you grow later.</p>

<p>You don’t need to master every corner of the GPU before you’re allowed to use it. Write something small. Let it run. Watch it scale. That’s already winning.</p>

<p>So if you’re walking away from this thinking, “Wait, I can actually write CUDA now,” — that’s exactly the feeling I wanted this blog to give you.</p>

<p>Onward.</p>

    </div>
  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/that-first-cuda-blog-2/">That First CUDA Blog I Needed :Part 2</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/that-first-cuda-blog-1/">That First CUDA Blog I Needed</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/that-first-cuda-blog/">That First CUDA Blog I Needed</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/hidden-speed-in-shared-memory/">Hidden Speed in CUDA's Shared Memory</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/a-practical-guide-to-quantization/">A practical guide to Quantization</a>
  </li>

</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Sanket R. Shah. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
